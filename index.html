<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#003f5c">
    <title>Ë∂ÖÈÄ≤ÂåñÁâàÔºÅÊµ∑„ÅÆÂ§ßÂÜíÈô∫„Ç≤„Éº„É†</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: linear-gradient(180deg, #0077be 0%, #003f5c 100%);
            font-family: 'Arial', sans-serif;
            touch-action: none;
        }

        #gameContainer {
            position: relative;
            width: 100%;
            height: 100%;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            background: linear-gradient(180deg, 
                rgba(135, 206, 250, 0.8) 0%, 
                rgba(70, 130, 180, 0.9) 30%, 
                rgba(25, 25, 112, 0.95) 70%, 
                rgba(0, 0, 139, 1) 100%);
            touch-action: none;
            cursor: pointer;
        }

        .ui-panel {
            position: absolute;
            background: rgba(0, 50, 100, 0.9);
            color: white;
            padding: 10px 15px;
            border-radius: 15px;
            font-weight: bold;
            font-size: 14px;
            backdrop-filter: blur(15px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            z-index: 100;
        }

        #scorePanel {
            top: 10px;
            left: 10px;
        }

        #levelPanel {
            top: 10px;
            right: 10px;
        }

        #comboPanel {
            top: 70px;
            left: 10px;
            background: rgba(255, 165, 0, 0.9);
            display: none;
        }

        #infoPanel {
            top: 10px;
            left: 50%;
            transform: translateX(-50%) scale(0.8);
            max-width: 200px;
            font-size: 10px;
            opacity: 0.8;
            text-align: center;
        }

        #skillsPanel {
            bottom: calc(env(safe-area-inset-bottom) + 10px);
            left: env(safe-area-inset-left, 10px);
            display: flex;
            flex-direction: row;
            gap: 8px;
            background: rgba(75, 0, 130, 0.6);
            border-radius: 10px;
            padding: 6px;
            opacity: 0.8;
            transform: scale(0.8);
        }

        .skill-button {
            background: linear-gradient(45deg, #ff6b35, #f7931e);
            border: none;
            color: white;
            padding: 6px 10px;
            border-radius: 15px;
            font-size: 11px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(255, 107, 53, 0.3);
            min-width: 60px;
            text-align: center;
        }

        .skill-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 53, 0.6);
        }

        .skill-button:active {
            transform: translateY(0);
        }

        .skill-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        #bossWarning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.9);
            color: white;
            padding: 20px;
            border-radius: 15px;
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            z-index: 200;
            display: none;
            backdrop-filter: blur(10px);
            border: 3px solid #FF6B35;
            box-shadow: 0 10px 30px rgba(255, 0, 0, 0.5);
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 30, 60, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .screen h1 {
            font-size: 36px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            background: linear-gradient(45deg, #00ffff, #0080ff, #ff6b35);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .screen p {
            font-size: 16px;
            margin-bottom: 30px;
            max-width: 80%;
            line-height: 1.5;
        }

        .button {
            background: linear-gradient(45deg, #ff6b35, #f7931e);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 107, 53, 0.4);
            touch-action: manipulation;
        }

        .button:hover, .button:active {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 53, 0.6);
        }

        #joystick {
            position: absolute;
            bottom: calc(env(safe-area-inset-bottom) + 20px);
            right: env(safe-area-inset-right, 20px);
            width: 80px;
            height: 80px;
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.4);
            border-radius: 50%;
            z-index: 100;
            touch-action: none;
            pointer-events: auto;
        }

        #joystickKnob {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 30px;
            height: 30px;
            background: linear-gradient(45deg, #00ffff, #0080ff);
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.1s ease;
            box-shadow: 0 4px 15px rgba(0, 255, 255, 0.4);
        }

        #joystickKnob.active {
            transform: translate(-50%, -50%) scale(1.1);
            box-shadow: 0 6px 20px rgba(0, 255, 255, 0.6);
        }

        #slowMotionEffect {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.1) 0%, transparent 70%);
            pointer-events: none;
            z-index: 50;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #slowMotionEffect.active {
            opacity: 1;
        }

        @media (max-width: 768px) {
            .screen h1 {
                font-size: 28px;
            }
            
            .screen p {
                font-size: 14px;
                padding: 0 20px;
            }
            
            .button {
                padding: 12px 24px;
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div id="scorePanel" class="ui-panel">
            „Çπ„Ç≥„Ç¢: <span id="scoreValue">0</span>
        </div>
        
        <div id="levelPanel" class="ui-panel">
            „É¨„Éô„É´: <span id="levelValue">1</span>
        </div>
        
        <div id="comboPanel" class="ui-panel">
            üî• <span id="comboValue">0</span> „Ç≥„É≥„ÉúÔºÅ
        </div>
        
        <div id="skillsPanel" class="ui-panel">
            <button id="freezeBtn" class="skill-button">‚ùÑÔ∏è ÊôÇÈñìÂÅúÊ≠¢</button>
            <button id="growBtn" class="skill-button">üêã Â∑®Â§ßÂåñ</button>
            <button id="magnetBtn" class="skill-button">üß≤ Á£ÅÁü≥</button>
        </div>
        
        <div id="infoPanel" class="ui-panel">
            <div id="playerInfo">üê† Â∞è„Åï„Å™È≠ö</div>
            <div style="margin-top: 5px;">
                ‰ΩìÂäõ: <div style="background: #333; height: 8px; border-radius: 4px; overflow: hidden; width: 120px; display: inline-block;">
                    <div id="healthFill" style="background: linear-gradient(90deg, #00ff00, #ffff00); height: 100%; width: 100%; transition: width 0.3s;"></div>
                </div>
            </div>
            <div style="margin-top: 5px;">
                ÈÖ∏Á¥†: <div style="background: #333; height: 8px; border-radius: 4px; overflow: hidden; width: 120px; display: inline-block;">
                    <div id="oxygenFill" style="background: linear-gradient(90deg, #00ff00, #ffff00); height: 100%; width: 100%; transition: width 0.3s;"></div>
                </div>
            </div>
            <div style="margin-top: 5px;">
                „Ç®„Éç„É´„ÇÆ„Éº: <div style="background: #333; height: 8px; border-radius: 4px; overflow: hidden; width: 120px; display: inline-block;">
                    <div id="energyFill" style="background: linear-gradient(90deg, #ff6b35, #f7931e); height: 100%; width: 100%; transition: width 0.3s;"></div>
                </div>
            </div>
            <div id="statusEffects" style="margin-top: 5px; font-size: 11px;"></div>
        </div>
        
        <div id="startScreen" class="screen">
            <h1>üåä Ë∂ÖÈÄ≤ÂåñÁâàÔºÅÊµ∑„ÅÆÂ§ßÂÜíÈô∫ÔºÅ üêü</h1>
            <p>Á©∂Ê•µ„ÅÆÊµ∑Ê¥ãÂÜíÈô∫„Ç≤„Éº„É†ÔºÅ<br>
            üî• „Ç≥„É≥„Éú„Ç∑„Çπ„ÉÜ„É† - ÈÄ£Á∂ö„ÅßÈ£ü„Åπ„Å¶Â§ßÈáè„Éú„Éº„Éä„ÇπÁç≤ÂæóÔºÅ<br>
            ‚ùÑÔ∏è ÊôÇÈñìÂÅúÊ≠¢ - Êïµ„ÅÆÂãï„Åç„ÇíÊ≠¢„ÇÅ„Å¶ÂÆâÂÖ®„Å´Ë°åÂãïÔºÅ<br>
            üêã Â∑®Â§ßÂåñ - ‰∏ÄÊôÇÁöÑ„Å´Â∑®Â§ß„Å´„Å™„Å£„Å¶Âº∑Êïµ„ÇÇÈ£ü„Åπ„ÇãÔºÅ<br>
            üß≤ Á£ÅÁü≥ÂäπÊûú - È£ü„ÅπÁâ©„ÇíËá™Âãï„ÅßÂºï„ÅçÂØÑ„ÅõÔºÅ<br>
            üíÄ „Éú„ÇπÊà¶ - ÂÆöÊúüÁöÑ„Å´Áèæ„Çå„ÇãÂ∑®Â§ß„Å™Êïµ„Å´ÊåëÊà¶ÔºÅ<br>
            üéØ „Çπ„Éû„Éº„ÉàAI - È≠ö„Åü„Å°„ÅåÊú¨Ê†ºÁöÑ„Å´ÊîªÊíÉ„Åó„Å¶„Åè„ÇãÔºÅ</p>
            <button id="startButton" class="button">üöÄ Ë∂ÖÂÜíÈô∫ÈñãÂßãÔºÅ</button>
        </div>
        
        <div id="gameOverScreen" class="screen" style="display: none;">
            <h1>üåä ÂÜíÈô∫ÁµÇ‰∫Ü üåä</h1>
            <p id="finalScore">„Çπ„Ç≥„Ç¢: 0</p>
            <p id="achievements"></p>
            <button id="restartButton" class="button">üîÑ „ÇÇ„ÅÜ‰∏ÄÂ∫¶Ë∂ÖÂÜíÈô∫</button>
        </div>

        <div id="joystick">
            <div id="joystickKnob"></div>
        </div>
        
        <div id="bossWarning">
            <div id="bossWarningText">‚ö†Ô∏è Âç±Èô∫Êé•ËøëÔºÅ‚ö†Ô∏è</div>
        </div>
        
        <div id="slowMotionEffect"></div>
    </div>

    <script>
        // Ë∂ÖÈÄ≤ÂåñÁâàÊµ∑Ê¥ãÁîüÁâ©„Ç≤„Éº„É†
        
        let GameState = {
            score: 0,
            level: 1,
            gameRunning: false,
            player: null,
            entities: [],
            particles: [],
            bubbles: [],
            animationId: null,
            oxygen: 100,
            energy: 100,
            isInvincible: false,
            invincibilityTime: 0,
            swallowingAnimations: [],
            joystick: {
                active: false,
                inputX: 0,
                inputY: 0
            },
            // „Ç≥„É≥„Éú„Ç∑„Çπ„ÉÜ„É†
            combo: 0,
            comboTimer: 0,
            // Êñ∞„Çπ„Ç≠„É´„Ç∑„Çπ„ÉÜ„É†
            isTimeFreeze: false,
            freezeTime: 0,
            isGiantMode: false,
            giantTime: 0,
            originalRadius: 15,
            magnetActive: false,
            magnetTime: 0,
            // „Ç®„Éï„Çß„ÇØ„Éà
            growthEffect: false,
            growthTime: 0,
            lastGrowthSize: 15,
            // „Çπ„Ç≠„É´„ÇØ„Éº„É´„ÉÄ„Ç¶„É≥
            freezeCooldown: 0,
            giantCooldown: 0,
            magnetCooldown: 0,
            // „Éú„Çπ„Ç∑„Çπ„ÉÜ„É†
            bossTimer: 0,
            bossActive: false,
            bossWarningTime: 0,
            lastBossSpawn: 0
        };

        let elements = {};

        // Êµ∑Ê¥ãÁîüÁâ©„ÅÆÂÆöÁæ©ÔºàÊîªÊíÉÁöÑ„Éê„É©„É≥„ÇπÁâàÔºâ
        const CreatureTypes = {
            // Â∞è„Åï„Å™ÁÑ°ÂÆ≥„Å™È≠ö 
            PLANKTON: {
                name: '„Éó„É©„É≥„ÇØ„Éà„É≥',
                size: 4,
                speed: 0.5,
                value: 3,
                behavior: 'drifting',
                color: '#90EE90',
                level: 1,
                dangerous: false,
                spawnWeight: 40
            },
            SMALL_FISH: {
                name: 'Â∞èÈ≠ö',
                size: 8,
                speed: 2,
                value: 8,
                behavior: 'schooling',
                color: '#FFD700',
                level: 1,
                dangerous: false,
                spawnWeight: 30
            },
            TROPICAL_FISH: {
                name: 'ÁÜ±Â∏ØÈ≠ö',
                size: 10,
                speed: 3,
                value: 12,
                behavior: 'colorful_swimming',
                color: '#FF69B4',
                level: 1,
                dangerous: false,
                spawnWeight: 25
            },
            ANGELFISH: {
                name: '„Ç®„É≥„Çº„É´„Éï„Ç£„ÉÉ„Ç∑„É•',
                size: 12,
                speed: 2.5,
                value: 15,
                behavior: 'graceful_swimming',
                color: '#87CEEB',
                level: 1,
                dangerous: false,
                spawnWeight: 20
            },
            
            // ‰∏≠Âûã„ÅÆÈ≠ö
            HORSE_MACKEREL: {
                name: '„Ç¢„Ç∏',
                size: 15,
                speed: 4,
                value: 25,
                behavior: 'fast_schooling',
                color: '#4169E1',
                level: 2,
                dangerous: false,
                spawnWeight: 15
            },
            TUNA: {
                name: '„Éû„Ç∞„É≠',
                size: 20,
                speed: 5,
                value: 40,
                behavior: 'speed_swimming',
                color: '#2F4F4F',
                level: 2,
                dangerous: false,
                spawnWeight: 12
            },
            SALMON: {
                name: '„Çµ„Ç±',
                size: 18,
                speed: 4,
                value: 35,
                behavior: 'upstream_swimming',
                color: '#FA8072',
                level: 2,
                dangerous: false,
                spawnWeight: 12
            },
            
            // ÊîªÊíÉÁöÑ„Å™È≠ö
            AGGRESSIVE_FISH: {
                name: 'ÊîªÊíÉÁöÑ„Å™È≠ö',
                size: 16,
                speed: 3.5,
                value: -30,
                behavior: 'aggressive_hunter',
                color: '#FF4500',
                level: 2,
                dangerous: true,
                isAggressive: true,
                spawnWeight: 70
            },
            PIRANHA: {
                name: '„Éî„É©„Éã„Ç¢',
                size: 12,
                speed: 4,
                value: -25,
                behavior: 'pack_hunter',
                color: '#DC143C',
                level: 2,
                dangerous: true,
                isAggressive: true,
                spawnWeight: 65
            },
            SWORDFISH: {
                name: '„Ç´„Ç∏„Ç≠',
                size: 25,
                speed: 4.5,
                value: -50,
                behavior: 'spear_attack',
                color: '#4682B4',
                level: 3,
                dangerous: true,
                isAggressive: true,
                spawnWeight: 50
            },
            MORAY_EEL: {
                name: '„Ç¶„ÉÑ„Éú',
                size: 20,
                speed: 3,
                value: -40,
                behavior: 'snake_attack',
                color: '#228B22',
                level: 3,
                dangerous: true,
                isAggressive: true,
                spawnWeight: 45
            },
            
            // Âç±Èô∫„Å™È≠ö
            TOXIC_FISH: {
                name: 'ÊØíÈ≠ö',
                size: 9,
                speed: 1.5,
                value: -20,
                behavior: 'toxic_swimming',
                color: '#FF1493',
                level: 1,
                dangerous: true,
                isToxic: true,
                spawnWeight: 35
            },
            PUFFERFISH: {
                name: '„Éï„Ç∞',
                size: 16,
                speed: 1.5,
                value: -25,
                behavior: 'puffer_defense',
                color: '#FFFF00',
                level: 2,
                dangerous: true,
                canInflate: true,
                spawnWeight: 30
            },
            STINGRAY: {
                name: '„Ç®„Ç§',
                size: 25,
                speed: 2,
                value: -30,
                behavior: 'bottom_dwelling',
                color: '#696969',
                level: 3,
                dangerous: true,
                spawnWeight: 15
            },
            
            // ÊçïÈ£üËÄÖ
            BABY_SHARK: {
                name: 'Â≠ê„Çµ„É°',
                size: 20,
                speed: 3,
                value: -40,
                behavior: 'smart_chase',
                color: '#708090',
                level: 2,
                dangerous: true,
                isAggressive: true,
                spawnWeight: 20
            },
            BARRACUDA: {
                name: '„Éê„É©„ÇØ„Éº„ÉÄ',
                size: 30,
                speed: 4,
                value: -60,
                behavior: 'ambush_predator',
                color: '#C0C0C0',
                level: 3,
                dangerous: true,
                isAggressive: true,
                spawnWeight: 15
            },
            
            // „Éú„ÇπÁ¥öÁîüÁâ©
            GREAT_WHITE_SHARK: {
                name: '„Éõ„Ç™„Ç∏„É≠„Ç∂„É°',
                size: 60,
                speed: 3.5,
                value: -150,
                behavior: 'apex_predator',
                color: '#708090',
                level: 4,
                dangerous: true,
                isApexPredator: true,
                isBoss: true,
                spawnWeight: 0
            },
            GIANT_OCTOPUS: {
                name: 'Â∑®Â§ß„Çø„Ç≥',
                size: 80,
                speed: 2.5,
                value: -200,
                behavior: 'tentacle_boss',
                color: '#8B0000',
                level: 5,
                dangerous: true,
                isBoss: true,
                spawnWeight: 0
            },
            ELECTRIC_EEL: {
                name: 'ÈõªÊ∞ó„Ç¶„Éä„ÇÆ',
                size: 40,
                speed: 3,
                value: -120,
                behavior: 'electric_attack',
                color: '#FFD700',
                level: 4,
                dangerous: true,
                isBoss: true,
                spawnWeight: 0
            },
            HAMMERHEAD_SHARK: {
                name: '„Éè„É≥„Éû„Éº„Éò„ÉÉ„Éâ„Ç∑„É£„Éº„ÇØ',
                size: 55,
                speed: 4,
                value: -140,
                behavior: 'hammer_attack',
                color: '#696969',
                level: 4,
                dangerous: true,
                isAggressive: true,
                isBoss: true,
                spawnWeight: 0
            },
            
            // ÁâπÊÆäÁîüÁâ©
            JELLYFISH: {
                name: '„ÇØ„É©„Ç≤',
                size: 22,
                speed: 0.8,
                value: -35,
                behavior: 'jellyfish_drift',
                color: '#DA70D6',
                level: 2,
                dangerous: true,
                isToxic: true,
                spawnWeight: 25
            },
            OCTOPUS: {
                name: '„Çø„Ç≥',
                size: 25,
                speed: 2,
                value: -40,
                behavior: 'intelligent_escape',
                color: '#8B0000',
                level: 3,
                dangerous: true,
                spawnWeight: 12
            },
            SQUID: {
                name: '„Ç§„Ç´',
                size: 22,
                speed: 3,
                value: -35,
                behavior: 'ink_escape',
                color: '#2F4F4F',
                level: 3,
                dangerous: true,
                spawnWeight: 15
            },
            
            // ÁâπÂà•„Ç¢„Ç§„ÉÜ„É†
            TREASURE: {
                name: 'ÂÆùÁÆ±',
                size: 15,
                speed: 0,
                value: 100,
                behavior: 'treasure',
                color: '#FFD700',
                level: 1,
                dangerous: false,
                spawnWeight: 3
            },
            HEALTH_POTION: {
                name: 'ÂõûÂæ©Ëñ¨',
                size: 10,
                speed: 0.3,
                value: 20,
                behavior: 'healing_drift',
                color: '#00FF00',
                level: 2,
                dangerous: false,
                isHealthItem: true,
                spawnWeight: 6
            },
            POWER_UP: {
                name: '„Éë„ÉØ„Éº„Ç¢„ÉÉ„Éó',
                size: 12,
                speed: 0.5,
                value: 50,
                behavior: 'power_up_glow',
                color: '#FFD700',
                level: 2,
                dangerous: false,
                isPowerUp: true,
                spawnWeight: 3
            },
            SPEED_BOOST: {
                name: '„Çπ„Éî„Éº„Éâ„Ç¢„ÉÉ„Éó',
                size: 10,
                speed: 1,
                value: 30,
                behavior: 'speed_boost_spin',
                color: '#FF4500',
                level: 2,
                dangerous: false,
                isSpeedBoost: true,
                spawnWeight: 4
            }
        };

        // Êñ∞„Åó„ÅÑ„Ç®„Éï„Çß„ÇØ„ÉàÈñ¢Êï∞
        function createTimeFreezeEffect() {
            for (let i = 0; i < 30; i++) {
                GameState.particles.push({
                    x: GameState.player.x + (Math.random() - 0.5) * 100,
                    y: GameState.player.y + (Math.random() - 0.5) * 100,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6,
                    color: '#87CEEB',
                    life: 2000,
                    maxLife: 2000,
                    alpha: 1,
                    size: 6
                });
            }
        }

        function createGiantModeEffect() {
            for (let i = 0; i < 25; i++) {
                GameState.particles.push({
                    x: GameState.player.x + (Math.random() - 0.5) * 80,
                    y: GameState.player.y + (Math.random() - 0.5) * 80,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    color: '#FFD700',
                    life: 1500,
                    maxLife: 1500,
                    alpha: 1,
                    size: 8
                });
            }
        }

        function createMagnetEffect() {
            for (let i = 0; i < 20; i++) {
                GameState.particles.push({
                    x: GameState.player.x + (Math.random() - 0.5) * 60,
                    y: GameState.player.y + (Math.random() - 0.5) * 60,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    color: '#FF6347',
                    life: 1200,
                    maxLife: 1200,
                    alpha: 1,
                    size: 5
                });
            }
        }

        function createAttackEffect(x, y, color) {
            for (let i = 0; i < 8; i++) {
                GameState.particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 5,
                    vy: (Math.random() - 0.5) * 5,
                    color: color,
                    life: 800,
                    maxLife: 800,
                    alpha: 1,
                    size: 4
                });
            }
        }

        function createTentacleEffect(x, y, angle) {
            for (let i = 0; i < 5; i++) {
                GameState.particles.push({
                    x: x + Math.cos(angle) * (i * 10),
                    y: y + Math.sin(angle) * (i * 10),
                    vx: Math.cos(angle) * 3,
                    vy: Math.sin(angle) * 3,
                    color: '#8B0000',
                    life: 1000,
                    maxLife: 1000,
                    alpha: 1,
                    size: 6
                });
            }
        }

        function createElectricEffect(x, y) {
            for (let i = 0; i < 15; i++) {
                GameState.particles.push({
                    x: x + (Math.random() - 0.5) * 40,
                    y: y + (Math.random() - 0.5) * 40,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6,
                    color: '#FFFF00',
                    life: 600,
                    maxLife: 600,
                    alpha: 1,
                    size: 3
                });
            }
        }

        function createHammerEffect(x, y) {
            for (let i = 0; i < 12; i++) {
                GameState.particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    color: '#696969',
                    life: 1000,
                    maxLife: 1000,
                    alpha: 1,
                    size: 7
                });
            }
        }

        function createBossDefeatEffect() {
            for (let i = 0; i < 50; i++) {
                GameState.particles.push({
                    x: GameState.player.x + (Math.random() - 0.5) * 200,
                    y: GameState.player.y + (Math.random() - 0.5) * 200,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    color: '#FFD700',
                    life: 3000,
                    maxLife: 3000,
                    alpha: 1,
                    size: 12
                });
            }
        }

        // Êñ∞„Åó„ÅÑÊîªÊíÉÁöÑ„Å™Ë°åÂãï„Éë„Çø„Éº„É≥
        function updateAggressiveHunter(entity) {
            const dx = GameState.player.x - entity.x;
            const dy = GameState.player.y - entity.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < 150) {
                // Áõ¥Êé•ÊîªÊíÉ
                entity.vx = (dx / dist) * entity.speed * 1.1;
                entity.vy = (dy / dist) * entity.speed * 1.1;
                entity.isAttacking = true;
                
                // ÊîªÊíÉ„Ç®„Éï„Çß„ÇØ„Éà
                if (entity.attackCooldown <= 0) {
                    createAttackEffect(entity.x, entity.y, entity.color);
                    entity.attackCooldown = 1000;
                }
            } else {
                updateWanderingBehavior(entity);
                entity.isAttacking = false;
            }
        }

        function updatePackHunter(entity) {
            // Áæ§„Çå„ÅßÂçîÂäõÊîªÊíÉ
            const sameType = GameState.entities.filter(e => e.type === entity.type && e !== entity);
            
            if (sameType.length > 0) {
                // Áæ§„Çå„ÅÆ‰∏≠ÂøÉ„Å´Âêë„Åã„ÅÜ
                let avgX = 0, avgY = 0;
                sameType.forEach(e => {
                    avgX += e.x;
                    avgY += e.y;
                });
                avgX /= sameType.length;
                avgY /= sameType.length;
                
                const dx = GameState.player.x - avgX;
                const dy = GameState.player.y - avgY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < 200) {
                    // ÂåÖÂõ≤ÊîªÊíÉ
                    const angle = Math.atan2(GameState.player.y - entity.y, GameState.player.x - entity.x);
                    entity.vx = Math.cos(angle) * entity.speed * 1.0;
                    entity.vy = Math.sin(angle) * entity.speed * 1.0;
                    entity.isAttacking = true;
                }
            } else {
                updateAggressiveHunter(entity);
            }
        }

        function updateSpearAttack(entity) {
            const dx = GameState.player.x - entity.x;
            const dy = GameState.player.y - entity.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < 250) {
                // Á™ÅÈÄ≤ÊîªÊíÉ
                if (entity.behaviorTimer > 1500) {
                    entity.vx = (dx / dist) * entity.speed * 1.5;
                    entity.vy = (dy / dist) * entity.speed * 1.5;
                    entity.isAttacking = true;
                    
                    if (entity.behaviorTimer > 2000) {
                        entity.behaviorTimer = 0;
                    }
                } else {
                    // Ê∫ñÂÇô„Éï„Çß„Éº„Ç∫
                    entity.vx *= 0.3;
                    entity.vy *= 0.3;
                }
            }
        }

        function updateSnakeAttack(entity) {
            const dx = GameState.player.x - entity.x;
            const dy = GameState.player.y - entity.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < 100) {
                // Ëõá„ÅÆ„Çà„ÅÜ„Å™Êõ≤„Åå„Çä„Åè„Å≠„Å£„ÅüÊîªÊíÉ
                const waveX = Math.sin(entity.glowTime * 5) * entity.speed * 0.3;
                const waveY = Math.cos(entity.glowTime * 3) * entity.speed * 0.3;
                
                entity.vx = (dx / dist) * entity.speed * 0.9 + waveX;
                entity.vy = (dy / dist) * entity.speed * 0.9 + waveY;
                entity.isAttacking = true;
            }
        }

        function updateTentacleBoss(entity) {
            const dx = GameState.player.x - entity.x;
            const dy = GameState.player.y - entity.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            // „Éú„Çπ„ÅØÂ∏∏„Å´„Éó„É¨„Ç§„É§„Éº„ÇíËøΩË∑°
            if (dist > 50) {
                entity.vx = (dx / dist) * entity.speed * 0.8;
                entity.vy = (dy / dist) * entity.speed * 0.8;
            }
            
            // ÁâπÊÆäÊîªÊíÉ
            if (entity.attackCooldown <= 0) {
                // Ëß¶ÊâãÊîªÊíÉ„Ç®„Éï„Çß„ÇØ„Éà
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    createTentacleEffect(entity.x, entity.y, angle);
                }
                entity.attackCooldown = 2000;
            }
        }

        function updateElectricAttack(entity) {
            const dx = GameState.player.x - entity.x;
            const dy = GameState.player.y - entity.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < 200) {
                entity.vx = (dx / dist) * entity.speed * 0.8;
                entity.vy = (dy / dist) * entity.speed * 0.8;
                
                // ÈõªÊ∞óÊîªÊíÉ
                if (entity.attackCooldown <= 0) {
                    createElectricEffect(entity.x, entity.y);
                    entity.attackCooldown = 1500;
                }
            }
        }

        function updateHammerAttack(entity) {
            const dx = GameState.player.x - entity.x;
            const dy = GameState.player.y - entity.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < 300) {
                // È´òÈÄüÁ™ÅÈÄ≤
                entity.vx = (dx / dist) * entity.speed * 1.2;
                entity.vy = (dy / dist) * entity.speed * 1.2;
                
                // „Éè„É≥„Éû„ÉºÊîªÊíÉ„Ç®„Éï„Çß„ÇØ„Éà
                if (entity.attackCooldown <= 0) {
                    createHammerEffect(entity.x, entity.y);
                    entity.attackCooldown = 2500;
                }
            }
        }

        function init() {
            console.log('=== Ë∂ÖÈÄ≤ÂåñÁâàÂàùÊúüÂåñÈñãÂßã ===');
            
            try {
                // DOMË¶ÅÁ¥†ÂèñÂæó
                elements.canvas = document.getElementById('gameCanvas');
                elements.ctx = elements.canvas ? elements.canvas.getContext('2d') : null;
                elements.startButton = document.getElementById('startButton');
                elements.restartButton = document.getElementById('restartButton');
                elements.joystick = document.getElementById('joystick');
                elements.joystickKnob = document.getElementById('joystickKnob');
                
                elements.scoreValue = document.getElementById('scoreValue');
                elements.levelValue = document.getElementById('levelValue');
                elements.comboValue = document.getElementById('comboValue');
                elements.comboPanel = document.getElementById('comboPanel');
                elements.healthFill = document.getElementById('healthFill');
                elements.oxygenFill = document.getElementById('oxygenFill');
                elements.energyFill = document.getElementById('energyFill');
                elements.playerInfo = document.getElementById('playerInfo');
                elements.statusEffects = document.getElementById('statusEffects');
                
                elements.startScreen = document.getElementById('startScreen');
                elements.gameOverScreen = document.getElementById('gameOverScreen');
                elements.finalScore = document.getElementById('finalScore');
                elements.achievements = document.getElementById('achievements');
                elements.slowMotionEffect = document.getElementById('slowMotionEffect');
                elements.bossWarning = document.getElementById('bossWarning');
                elements.bossWarningText = document.getElementById('bossWarningText');
                
                // „Çπ„Ç≠„É´„Éú„Çø„É≥
                elements.freezeBtn = document.getElementById('freezeBtn');
                elements.growBtn = document.getElementById('growBtn');
                elements.magnetBtn = document.getElementById('magnetBtn');
                
                if (!elements.canvas || !elements.ctx) {
                    console.error('„Ç≠„É£„É≥„Éê„Çπ„Åæ„Åü„ÅØ„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„ÅåÂèñÂæó„Åß„Åç„Åæ„Åõ„Çì');
                    return;
                }
                
                resizeCanvas();
                elements.canvas.style.touchAction = 'none';
                
                setupEvents();
                initBubbles();
                
                console.log('=== Ë∂ÖÈÄ≤ÂåñÁâàÂàùÊúüÂåñÂÆå‰∫Ü ===');
                
            } catch (error) {
                console.error('ÂàùÊúüÂåñ„Ç®„É©„Éº:', error);
            }
        }

        function resizeCanvas() {
            if (elements.canvas) {
                elements.canvas.width = window.innerWidth;
                elements.canvas.height = window.innerHeight;
            }
        }

        function setupEvents() {
            if (elements.startButton) {
                elements.startButton.onclick = startGame;
                elements.startButton.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    startGame();
                }, { passive: false });
            }
            
            if (elements.restartButton) {
                elements.restartButton.onclick = startGame;
                elements.restartButton.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    startGame();
                }, { passive: false });
            }
            
            if (elements.canvas) {
                elements.canvas.addEventListener('touchstart', handleTouch, { passive: false });
                elements.canvas.addEventListener('click', handleClick);
            }
            
            // „Çπ„Ç≠„É´„Éú„Çø„É≥„ÅÆ„Ç§„Éô„É≥„Éà
            if (elements.freezeBtn) {
                elements.freezeBtn.onclick = useTimeFreeze;
                elements.freezeBtn.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    useTimeFreeze();
                }, { passive: false });
            }
            
            if (elements.growBtn) {
                elements.growBtn.onclick = useGiantMode;
                elements.growBtn.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    useGiantMode();
                }, { passive: false });
            }
            
            if (elements.magnetBtn) {
                elements.magnetBtn.onclick = useMagnet;
                elements.magnetBtn.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    useMagnet();
                }, { passive: false });
            }
            
            setupJoystick();
            window.addEventListener('resize', resizeCanvas);
        }

        function setupJoystick() {
            if (!elements.joystick || !elements.joystickKnob) return;
            
            let isDragging = false;
            const maxDistance = 25;
            
            function getJoystickCenter() {
                const rect = elements.joystick.getBoundingClientRect();
                return {
                    x: rect.left + rect.width / 2,
                    y: rect.top + rect.height / 2
                };
            }
            
            function handleJoystickStart(e) {
                e.preventDefault();
                e.stopPropagation();
                isDragging = true;
                GameState.joystick.active = true;
                elements.joystickKnob.classList.add('active');
                updateJoystick(e);
            }
            
            function handleJoystickMove(e) {
                if (!isDragging) return;
                e.preventDefault();
                updateJoystick(e);
            }
            
            function handleJoystickEnd(e) {
                e.preventDefault();
                isDragging = false;
                GameState.joystick.active = false;
                GameState.joystick.inputX = 0;
                GameState.joystick.inputY = 0;
                elements.joystickKnob.classList.remove('active');
                
                elements.joystickKnob.style.left = '50%';
                elements.joystickKnob.style.top = '50%';
            }
            
            function updateJoystick(e) {
                const center = getJoystickCenter();
                let clientX, clientY;
                
                if (e.touches && e.touches[0]) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                
                const deltaX = clientX - center.x;
                const deltaY = clientY - center.y;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                if (distance <= maxDistance) {
                    GameState.joystick.inputX = deltaX / maxDistance;
                    GameState.joystick.inputY = deltaY / maxDistance;
                } else {
                    GameState.joystick.inputX = (deltaX / distance);
                    GameState.joystick.inputY = (deltaY / distance);
                }
                
                const knobX = 50 + (GameState.joystick.inputX * 40);
                const knobY = 50 + (GameState.joystick.inputY * 40);
                elements.joystickKnob.style.left = knobX + '%';
                elements.joystickKnob.style.top = knobY + '%';
            }
            
            elements.joystick.addEventListener('touchstart', handleJoystickStart, { passive: false });
            elements.joystick.addEventListener('mousedown', handleJoystickStart);
            
            document.addEventListener('touchmove', handleJoystickMove, { passive: false });
            document.addEventListener('mousemove', handleJoystickMove);
            
            document.addEventListener('touchend', handleJoystickEnd, { passive: false });
            document.addEventListener('mouseup', handleJoystickEnd);
        }

        function handleTouch(e) {
            if (!GameState.gameRunning) return;
            
            e.preventDefault();
            e.stopPropagation();
            
            const touch = e.touches[0];
            if (!touch) return;
            
            const rect = elements.canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            if (GameState.player) {
                GameState.player.targetX = x;
                GameState.player.targetY = y;
            }
        }

        function handleClick(e) {
            if (!GameState.gameRunning) return;
            
            e.preventDefault();
            
            const rect = elements.canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (GameState.player) {
                GameState.player.targetX = x;
                GameState.player.targetY = y;
            }
        }

        function initBubbles() {
            GameState.bubbles = [];
            for (let i = 0; i < 25; i++) {
                createBubble();
            }
        }

        function createBubble() {
            GameState.bubbles.push({
                x: Math.random() * elements.canvas.width,
                y: elements.canvas.height + 20,
                radius: Math.random() * 6 + 2,
                speed: Math.random() * 3 + 0.5,
                alpha: Math.random() * 0.6 + 0.3,
                shimmer: Math.random() * Math.PI * 2
            });
        }

        // „Çπ„Ç≠„É´Èñ¢Êï∞ÔºàÂº∑ÂåñÁâàÔºâ
        function useTimeFreeze() {
            if (GameState.freezeCooldown > 0 || GameState.energy < 50) return;
            
            GameState.isTimeFreeze = true;
            GameState.freezeTime = 3000; // 3ÁßíÈñì
            GameState.energy -= 50;
            GameState.freezeCooldown = 8000; // 8Áßí„ÇØ„Éº„É´„ÉÄ„Ç¶„É≥
            
            createTimeFreezeEffect();
            updateUI();
        }

        function useGiantMode() {
            if (GameState.giantCooldown > 0 || GameState.energy < 60) return;
            
            GameState.isGiantMode = true;
            GameState.giantTime = 4000; // 4ÁßíÈñì
            GameState.originalRadius = GameState.player.radius;
            GameState.player.radius *= 2.5; // 2.5ÂÄç„ÅÆÂ§ß„Åç„Åï„Å´
            GameState.energy -= 60;
            GameState.giantCooldown = 10000; // 10Áßí„ÇØ„Éº„É´„ÉÄ„Ç¶„É≥
            
            createGiantModeEffect();
            updateUI();
        }

        function useMagnet() {
            if (GameState.magnetCooldown > 0 || GameState.energy < 35) return;
            
            GameState.magnetActive = true;
            GameState.magnetTime = 5000; // 5ÁßíÈñì
            GameState.energy -= 35;
            GameState.magnetCooldown = 6000; // 6Áßí„ÇØ„Éº„É´„ÉÄ„Ç¶„É≥
            
            createMagnetEffect();
            updateUI();
        }

        function startGame() {
            GameState.score = 0;
            GameState.level = 1;
            GameState.entities = [];
            GameState.particles = [];
            GameState.swallowingAnimations = [];
            GameState.gameRunning = true;
            GameState.oxygen = 100;
            GameState.energy = 100;
            GameState.isInvincible = false;
            GameState.invincibilityTime = 0;
            GameState.combo = 0;
            GameState.comboTimer = 0;
            GameState.isTimeFreeze = false;
            GameState.freezeTime = 0;
            GameState.isGiantMode = false;
            GameState.giantTime = 0;
            GameState.originalRadius = 15;
            GameState.magnetActive = false;
            GameState.magnetTime = 0;
            GameState.growthEffect = false;
            GameState.growthTime = 0;
            GameState.lastGrowthSize = 15;
            GameState.freezeCooldown = 0;
            GameState.giantCooldown = 0;
            GameState.magnetCooldown = 0;
            GameState.bossTimer = 0;
            GameState.bossActive = false;
            GameState.bossWarningTime = 0;
            GameState.lastBossSpawn = 0;
            
            GameState.player = {
                x: elements.canvas.width / 2,
                y: elements.canvas.height / 2,
                targetX: elements.canvas.width / 2,
                targetY: elements.canvas.height / 2,
                radius: 15,
                speed: 3,
                health: 100,
                angle: 0,
                color: '#FFD700',
                glowIntensity: 0
            };
            
            elements.startScreen.style.display = 'none';
            elements.gameOverScreen.style.display = 'none';
            elements.joystick.style.display = 'block';
            elements.slowMotionEffect.classList.remove('active');
            elements.bossWarning.style.display = 'none';
            
            updateUI();
            
            // ÂàùÊúü„Ç®„É≥„ÉÜ„Ç£„ÉÜ„Ç£ÁîüÊàê
            for (let i = 0; i < 12; i++) {
                spawnEntity();
            }
            
            if (GameState.animationId) {
                cancelAnimationFrame(GameState.animationId);
            }
            gameLoop();
        }

        function spawnEntity() {
            // Èáç„Åø‰ªò„ÅçÁ¢∫Áéá„Åß„Ç®„É≥„ÉÜ„Ç£„ÉÜ„Ç£„ÇíÈÅ∏Êäû
            const totalWeight = Object.values(CreatureTypes).reduce((sum, type) => {
                if ((!type.level || type.level <= GameState.level + 1) && !type.isBoss) {
                    return sum + (type.spawnWeight || 1);
                }
                return sum;
            }, 0);
            
            let randomWeight = Math.random() * totalWeight;
            let selectedType = null;
            
            for (const [key, type] of Object.entries(CreatureTypes)) {
                if ((!type.level || type.level <= GameState.level + 1) && !type.isBoss) {
                    randomWeight -= (type.spawnWeight || 1);
                    if (randomWeight <= 0) {
                        selectedType = key;
                        break;
                    }
                }
            }
            
            if (!selectedType) return;
            
            const creatureType = CreatureTypes[selectedType];
            const side = Math.floor(Math.random() * 4);
            let x, y;
            
            switch (side) {
                case 0: // ‰∏ä
                    x = Math.random() * elements.canvas.width;
                    y = -50;
                    break;
                case 1: // Âè≥
                    x = elements.canvas.width + 50;
                    y = Math.random() * elements.canvas.height;
                    break;
                case 2: // ‰∏ã
                    x = Math.random() * elements.canvas.width;
                    y = elements.canvas.height + 50;
                    break;
                case 3: // Â∑¶
                    x = -50;
                    y = Math.random() * elements.canvas.height;
                    break;
            }
            
            const entity = {
                x: x,
                y: y,
                type: selectedType,
                radius: creatureType.size,
                speed: creatureType.speed,
                vx: (Math.random() - 0.5) * creatureType.speed,
                vy: (Math.random() - 0.5) * creatureType.speed,
                color: creatureType.color,
                dangerous: creatureType.dangerous,
                value: creatureType.value,
                angle: Math.atan2((Math.random() - 0.5), (Math.random() - 0.5)),
                behavior: creatureType.behavior,
                behaviorTimer: 0,
                alertDistance: 120 + creatureType.size * 2,
                chaseDistance: 80 + creatureType.size,
                fleeDistance: 50 + creatureType.size,
                lastPlayerDistance: 1000,
                aiState: 'wandering',
                targetX: Math.random() * elements.canvas.width,
                targetY: Math.random() * elements.canvas.height,
                glowTime: 0,
                pulsePhase: Math.random() * Math.PI * 2,
                attackCooldown: 0,
                isAttacking: false
            };
            
            GameState.entities.push(entity);
        }

        // „Éú„ÇπÂá∫Áèæ„Ç∑„Çπ„ÉÜ„É†
        function spawnBoss() {
            const bossTypes = ['GREAT_WHITE_SHARK', 'GIANT_OCTOPUS', 'ELECTRIC_EEL', 'HAMMERHEAD_SHARK'];
            const selectedBoss = bossTypes[Math.floor(Math.random() * bossTypes.length)];
            const bossType = CreatureTypes[selectedBoss];
            
            // „Éú„ÇπË≠¶ÂëäË°®Á§∫
            elements.bossWarningText.textContent = `‚ö†Ô∏è ${bossType.name} Êé•Ëøë‰∏≠ÔºÅ‚ö†Ô∏è`;
            elements.bossWarning.style.display = 'block';
            GameState.bossWarningTime = 2000;
            
            // 2ÁßíÂæå„Å´„Éú„ÇπÂá∫Áèæ
            setTimeout(() => {
                const side = Math.floor(Math.random() * 4);
                let x, y;
                
                switch (side) {
                    case 0: // ‰∏ä
                        x = Math.random() * elements.canvas.width;
                        y = -100;
                        break;
                    case 1: // Âè≥
                        x = elements.canvas.width + 100;
                        y = Math.random() * elements.canvas.height;
                        break;
                    case 2: // ‰∏ã
                        x = Math.random() * elements.canvas.width;
                        y = elements.canvas.height + 100;
                        break;
                    case 3: // Â∑¶
                        x = -100;
                        y = Math.random() * elements.canvas.height;
                        break;
                }
                
                const boss = {
                    x: x,
                    y: y,
                    type: selectedBoss,
                    radius: bossType.size,
                    speed: bossType.speed,
                    vx: 0,
                    vy: 0,
                    color: bossType.color,
                    dangerous: true,
                    value: bossType.value,
                    angle: 0,
                    behavior: bossType.behavior,
                    behaviorTimer: 0,
                    alertDistance: 200,
                    chaseDistance: 150,
                    fleeDistance: 0,
                    lastPlayerDistance: 1000,
                    aiState: 'hunting',
                    targetX: GameState.player.x,
                    targetY: GameState.player.y,
                    glowTime: 0,
                    pulsePhase: 0,
                    attackCooldown: 0,
                    isAttacking: false,
                    isBoss: true,
                    health: 3 // „Éú„Çπ„ÅØ3ÂõûÊîªÊíÉ„ÅßÂÄí„Åõ„Çã
                };
                
                GameState.entities.push(boss);
                GameState.bossActive = true;
                GameState.lastBossSpawn = Date.now();
            }, 2000);
        }

        function gameLoop() {
            if (!GameState.gameRunning) return;
            
            // ÈÄöÂ∏∏„ÅØ16ms„ÄÅÊôÇÈñìÂÅúÊ≠¢‰∏≠„Åß„ÇÇÊúÄ‰ΩéÈôê„ÅÆÊõ¥Êñ∞„ÅØÂøÖË¶Å
            const deltaTime = 16;
            
            update(deltaTime);
            render();
            
            GameState.animationId = requestAnimationFrame(gameLoop);
        }

        function update(deltaTime) {
            updatePlayer(deltaTime);
            updateEntities(deltaTime);
            updateParticles(deltaTime);
            updateBubbles(deltaTime);
            updateSwallowingAnimations(deltaTime);
            updateSkills(deltaTime);
            updateCombo(deltaTime);
            updateBossSystem(deltaTime);
            checkCollisions();
            spawnNewEntities();
            updateOxygen(deltaTime);
            updateEnergy(deltaTime);
            checkLevelUp();
            checkGrowthEffect();
        }

        function updatePlayer(deltaTime) {
            const player = GameState.player;
            let moveX = 0, moveY = 0;
            let speedMultiplier = 1;
            
            // Â∑®Â§ßÂåñ„É¢„Éº„Éâ‰∏≠„ÅØÂ∞ë„ÅóÈÅÖ„Åè„Å™„Çã
            if (GameState.isGiantMode) {
                speedMultiplier = 0.7;
            }
            
            if (GameState.joystick.active) {
                moveX = GameState.joystick.inputX * player.speed * speedMultiplier;
                moveY = GameState.joystick.inputY * player.speed * speedMultiplier;
                player.x += moveX;
                player.y += moveY;
            } else {
                const dx = player.targetX - player.x;
                const dy = player.targetY - player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 3) {
                    moveX = (dx / distance) * player.speed * speedMultiplier;
                    moveY = (dy / distance) * player.speed * speedMultiplier;
                    player.x += moveX;
                    player.y += moveY;
                }
            }
            
            if (Math.abs(moveX) > 0.1 || Math.abs(moveY) > 0.1) {
                player.angle = Math.atan2(moveY, moveX);
            }
            
            player.x = Math.max(player.radius, Math.min(elements.canvas.width - player.radius, player.x));
            player.y = Math.max(player.radius, Math.min(elements.canvas.height - player.radius, player.y));
            
            // Âº∑Âåñ„Åï„Çå„ÅüÁ£ÅÁü≥ÂäπÊûú
            if (GameState.magnetActive) {
                GameState.entities.forEach(entity => {
                    if (!entity.dangerous && entity.value > 0) {
                        const dx = player.x - entity.x;
                        const dy = player.y - entity.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < 200) {
                            const force = 0.8; // Âº∑Âåñ
                            entity.vx += (dx / distance) * force;
                            entity.vy += (dy / distance) * force;
                        }
                    }
                });
            }
            
            // ÊàêÈï∑„Ç®„Éï„Çß„ÇØ„Éà
            if (player.radius > GameState.lastGrowthSize + 5) {
                GameState.growthEffect = true;
                GameState.growthTime = 1000;
                GameState.lastGrowthSize = player.radius;
            }
        }

        function updateEntities(deltaTime) {
            // ÊôÇÈñìÂÅúÊ≠¢‰∏≠„ÅØÊïµ„ÅÆÂãï„Åç„ÇíÂ§ßÂπÖ„Å´ÈÅÖ„Åè„Åô„Çã
            const speedMultiplier = GameState.isTimeFreeze ? 0.1 : 1;
            
            GameState.entities = GameState.entities.filter(entity => {
                // ÊôÇÈñìÂÅúÊ≠¢„ÅÆÂΩ±Èüø„ÇíÂèó„Åë„Å™„ÅÑÂ†¥Âêà„ÅÆ„ÅøAIÊõ¥Êñ∞
                if (!GameState.isTimeFreeze || entity.isBoss) {
                    updateEntityAI(entity, deltaTime);
                }
                
                // ÁßªÂãïÔºàÊôÇÈñìÂÅúÊ≠¢„ÅÆÂΩ±Èüø„ÇíÂèó„Åë„ÇãÔºâ
                entity.x += entity.vx * speedMultiplier;
                entity.y += entity.vy * speedMultiplier;
                
                // ËßíÂ∫¶Êõ¥Êñ∞
                if (Math.abs(entity.vx) > 0.1 || Math.abs(entity.vy) > 0.1) {
                    entity.angle = Math.atan2(entity.vy, entity.vx);
                }
                
                // Ë°åÂãïÊõ¥Êñ∞
                updateEntityBehavior(entity, deltaTime);
                
                entity.behaviorTimer += deltaTime;
                entity.glowTime += deltaTime * 0.001;
                
                if (entity.attackCooldown > 0) {
                    entity.attackCooldown -= deltaTime;
                }
                
                return entity.x > -200 && entity.x < elements.canvas.width + 200 &&
                       entity.y > -200 && entity.y < elements.canvas.height + 200;
            });
        }

        function updateEntityAI(entity, deltaTime) {
            const player = GameState.player;
            const dx = player.x - entity.x;
            const dy = player.y - entity.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            const canEatPlayer = entity.radius > player.radius * 0.8;
            const playerCanEat = player.radius > entity.radius * 0.8;
            
            // „Éó„É¨„Ç§„É§„Éº„ÅåÂ§ß„Åç„Åô„Åé„ÇãÂ†¥Âêà„ÅØÈÄÉ„Åí„Çã
            if (playerCanEat && !entity.dangerous && distance < entity.fleeDistance * 2) {
                entity.aiState = 'fleeing';
                entity.vx = -(dx / distance) * entity.speed * 1.3;
                entity.vy = -(dy / distance) * entity.speed * 1.3;
            }
            // Âç±Èô∫„Å™ÁîüÁâ©„Åß„ÄÅ„Éó„É¨„Ç§„É§„Éº„ÇíÈ£ü„Åπ„Çâ„Çå„ÇãÂ†¥Âêà„ÅØËøΩË∑°
            else if (entity.dangerous && canEatPlayer && distance < entity.alertDistance) {
                entity.aiState = 'chasing';
                entity.vx = (dx / distance) * entity.speed * 1.0;
                entity.vy = (dy / distance) * entity.speed * 1.0;
            }
            // ÊîªÊíÉÁØÑÂõ≤ÂÜÖ
            else if (entity.dangerous && distance < entity.chaseDistance) {
                entity.aiState = 'attacking';
                entity.vx = (dx / distance) * entity.speed * 1.1;
                entity.vy = (dy / distance) * entity.speed * 1.1;
            }
            // „Åù„Çå‰ª•Â§ñ„ÅØÂü∫Êú¨Ë°åÂãï
            else {
                entity.aiState = 'wandering';
                updateWanderingBehavior(entity);
            }
            
            entity.lastPlayerDistance = distance;
        }

        function updateEntityBehavior(entity, deltaTime) {
            const behavior = entity.behavior;
            
            switch (behavior) {
                case 'schooling':
                    updateSchoolingBehavior(entity);
                    break;
                case 'fast_schooling':
                    updateFastSchoolingBehavior(entity);
                    break;
                case 'colorful_swimming':
                    updateColorfulSwimming(entity);
                    break;
                case 'graceful_swimming':
                    updateGracefulSwimming(entity);
                    break;
                case 'speed_swimming':
                    updateSpeedSwimming(entity);
                    break;
                case 'upstream_swimming':
                    updateUpstreamSwimming(entity);
                    break;
                case 'smart_chase':
                    updateSmartChase(entity);
                    break;
                case 'ambush_predator':
                    updateAmbushPredator(entity);
                    break;
                case 'apex_predator':
                    updateApexPredator(entity);
                    break;
                case 'aggressive_hunter':
                    updateAggressiveHunter(entity);
                    break;
                case 'pack_hunter':
                    updatePackHunter(entity);
                    break;
                case 'spear_attack':
                    updateSpearAttack(entity);
                    break;
                case 'snake_attack':
                    updateSnakeAttack(entity);
                    break;
                case 'tentacle_boss':
                    updateTentacleBoss(entity);
                    break;
                case 'electric_attack':
                    updateElectricAttack(entity);
                    break;
                case 'hammer_attack':
                    updateHammerAttack(entity);
                    break;
                case 'jellyfish_drift':
                    updateJellyfishDrift(entity);
                    break;
                case 'intelligent_escape':
                    updateIntelligentEscape(entity);
                    break;
                case 'ink_escape':
                    updateInkEscape(entity);
                    break;
                case 'toxic_swimming':
                    updateToxicSwimming(entity);
                    break;
                case 'puffer_defense':
                    updatePufferDefense(entity);
                    break;
                case 'bottom_dwelling':
                    updateBottomDwelling(entity);
                    break;
                case 'healing_drift':
                    updateHealingDrift(entity);
                    break;
                case 'power_up_glow':
                    updatePowerUpGlow(entity);
                    break;
                case 'speed_boost_spin':
                    updateSpeedBoostSpin(entity);
                    break;
                case 'drifting':
                    updateDriftingBehavior(entity);
                    break;
                default:
                    updateWanderingBehavior(entity);
            }
        }

        // Ë°åÂãï„Éë„Çø„Éº„É≥ÔºàÂº∑ÂåñÁâàÔºâ
        function updateSchoolingBehavior(entity) {
            // ‰ªñ„ÅÆÂêåÁ®Æ„Å®„ÅÆÁæ§„ÇåË°åÂãï
            const sameType = GameState.entities.filter(e => e.type === entity.type && e !== entity);
            if (sameType.length > 0) {
                let avgX = 0, avgY = 0;
                sameType.forEach(e => {
                    avgX += e.x;
                    avgY += e.y;
                });
                avgX /= sameType.length;
                avgY /= sameType.length;
                
                const dx = avgX - entity.x;
                const dy = avgY - entity.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 0 && dist < 100) {
                    entity.vx += (dx / dist) * 0.2;
                    entity.vy += (dy / dist) * 0.2;
                }
            }
            
            // „Éó„É¨„Ç§„É§„Éº„Åã„ÇâÈÄÉ„Åí„Çã
            const playerDx = GameState.player.x - entity.x;
            const playerDy = GameState.player.y - entity.y;
            const playerDist = Math.sqrt(playerDx * playerDx + playerDy * playerDy);
            if (playerDist < 60) {
                entity.vx -= playerDx * 0.02;
                entity.vy -= playerDy * 0.02;
            }
        }

        function updateFastSchoolingBehavior(entity) {
            updateSchoolingBehavior(entity);
            entity.vx *= 1.1;
            entity.vy *= 1.1;
        }

        function updateColorfulSwimming(entity) {
            // Ëâ≤„ÇíÂ§âÂåñ„Åï„Åõ„Çã
            const hue = (entity.glowTime * 100 + entity.pulsePhase) % 360;
            entity.color = `hsl(${hue}, 80%, 60%)`;
            
            // Ê≥¢Áä∂„ÅÆÂãï„Åç
            entity.vx += Math.sin(entity.glowTime * 2) * 0.1;
            entity.vy += Math.cos(entity.glowTime * 1.5) * 0.1;
        }

        function updateGracefulSwimming(entity) {
            // ÂÑ™ÈõÖ„Å™Âãï„Åç
            entity.vx = Math.sin(entity.glowTime) * entity.speed * 0.8;
            entity.vy = Math.cos(entity.glowTime * 0.7) * entity.speed * 0.6;
        }

        function updateSpeedSwimming(entity) {
            // È´òÈÄüÁõ¥Á∑öÁßªÂãï
            if (entity.behaviorTimer > 2000) {
                entity.targetX = Math.random() * elements.canvas.width;
                entity.targetY = Math.random() * elements.canvas.height;
                entity.behaviorTimer = 0;
            }
            
            const dx = entity.targetX - entity.x;
            const dy = entity.targetY - entity.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist > 0) {
                entity.vx = (dx / dist) * entity.speed * 1.2;
                entity.vy = (dy / dist) * entity.speed * 1.2;
            }
        }

        function updateUpstreamSwimming(entity) {
            // ‰∏äÊµÅ„Å´Âêë„Åã„ÅÜÂãï„Åç
            entity.vy = -entity.speed * 0.5;
            entity.vx = Math.sin(entity.glowTime) * entity.speed * 0.3;
        }

        function updateSmartChase(entity) {
            // Ë≥¢„ÅÑËøΩË∑°Ôºà‰∫àÊ∏¨ÁßªÂãïÔºâ
            const dx = GameState.player.x - entity.x;
            const dy = GameState.player.y - entity.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < 150) {
                // „Éó„É¨„Ç§„É§„Éº„ÅÆÁßªÂãï„Çí‰∫àÊ∏¨
                const predictX = GameState.player.x + (GameState.player.targetX - GameState.player.x) * 0.5;
                const predictY = GameState.player.y + (GameState.player.targetY - GameState.player.y) * 0.5;
                
                const predDx = predictX - entity.x;
                const predDy = predictY - entity.y;
                const predDist = Math.sqrt(predDx * predDx + predDy * predDy);
                
                if (predDist > 0) {
                    entity.vx = (predDx / predDist) * entity.speed * 1.0;
                    entity.vy = (predDy / predDist) * entity.speed * 1.0;
                }
            }
        }

        function updateAmbushPredator(entity) {
            // ÂæÖ„Å°‰ºè„ÅõË°åÂãï
            if (entity.behaviorTimer < 1000) {
                entity.vx *= 0.5; // ÂæÖÊ©ü
                entity.vy *= 0.5;
            } else {
                // Á™ÅÁÑ∂„ÅÆÈ´òÈÄü„Ç¢„Çø„ÉÉ„ÇØ
                const dx = GameState.player.x - entity.x;
                const dy = GameState.player.y - entity.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < 200) {
                    entity.vx = (dx / dist) * entity.speed * 1.3;
                    entity.vy = (dy / dist) * entity.speed * 1.3;
                }
            }
        }

        function updateApexPredator(entity) {
            // È†ÇÁÇπÊçïÈ£üËÄÖ„ÅÆË°åÂãï
            const dx = GameState.player.x - entity.x;
            const dy = GameState.player.y - entity.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < 300) {
                entity.vx = (dx / dist) * entity.speed * 1.0;
                entity.vy = (dy / dist) * entity.speed * 1.0;
                
                // Â®ÅÂöá„Ç®„Éï„Çß„ÇØ„Éà
                if (Math.random() < 0.01) {
                    createThreatEffect(entity.x, entity.y);
                }
            }
        }

        function updateJellyfishDrift(entity) {
            // „ÇØ„É©„Ç≤„ÅÆÊµÆÈÅä
            entity.vx = Math.sin(entity.glowTime * 0.5) * 0.5;
            entity.vy = Math.cos(entity.glowTime * 0.3) * 0.3 + 0.2;
            
            // ÊØí„Ç®„Éï„Çß„ÇØ„Éà
            if (Math.random() < 0.005) {
                createToxicParticle(entity.x, entity.y);
            }
        }

        function updateIntelligentEscape(entity) {
            // Áü•ÁöÑ„Å™ÈÄÉÈÅøË°åÂãï
            const dx = GameState.player.x - entity.x;
            const dy = GameState.player.y - entity.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < 80) {
                // ÈöúÂÆ≥Áâ©„ÇíÂà©Áî®„Åó„ÅüÈÄÉÈÅø
                const escapeX = entity.x - dx * 2;
                const escapeY = entity.y - dy * 2;
                
                entity.vx = (escapeX - entity.x) * 0.1;
                entity.vy = (escapeY - entity.y) * 0.1;
                
                // Â§âË£Ö„Ç®„Éï„Çß„ÇØ„Éà
                entity.camouflageTime = 1000;
            }
        }

        function updateInkEscape(entity) {
            // „Ç§„Ç´„ÅÆÂ¢®Âêê„ÅçÈÄÉÈÅø
            const dx = GameState.player.x - entity.x;
            const dy = GameState.player.y - entity.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < 60 && !entity.inkCooldown) {
                entity.inkCooldown = 5000;
                createInkCloud(entity.x, entity.y);
                
                // ÊÄ•ÈÄüÈÄÉÈÅø
                entity.vx = -(dx / dist) * entity.speed * 2;
                entity.vy = -(dy / dist) * entity.speed * 2;
            }
            
            if (entity.inkCooldown) {
                entity.inkCooldown -= 16;
            }
        }

        function updateToxicSwimming(entity) {
            updateWanderingBehavior(entity);
            
            // ÊØí„ÅÆÁóïË∑°
            if (Math.random() < 0.008) {
                createToxicParticle(entity.x, entity.y);
            }
        }

        function updatePufferDefense(entity) {
            const dx = GameState.player.x - entity.x;
            const dy = GameState.player.y - entity.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < 50 && !entity.isInflated) {
                entity.isInflated = true;
                entity.originalRadius = entity.radius;
                entity.radius *= 1.5;
                entity.speed *= 0.5;
                
                // ËÜ®Âºµ„Ç®„Éï„Çß„ÇØ„Éà
                createInflationEffect(entity.x, entity.y);
            }
            
            if (entity.isInflated && dist > 100) {
                entity.isInflated = false;
                entity.radius = entity.originalRadius;
                entity.speed /= 0.5;
            }
        }

        function updateBottomDwelling(entity) {
            // Â∫ï„ÇíÈÄô„ÅÜÂãï„Åç
            entity.y = Math.max(entity.y, elements.canvas.height - 50);
            entity.vx = Math.sin(entity.glowTime * 0.5) * entity.speed * 0.7;
            entity.vy = Math.abs(entity.vy) * -0.1; // Â∫ï„Å´Âêë„Åã„ÅÜ
        }

        function updateHealingDrift(entity) {
            // ÂõûÂæ©„Ç¢„Ç§„ÉÜ„É†„ÅÆÊµÆÈÅä
            entity.vy = Math.sin(entity.glowTime * 0.8) * 0.5;
            entity.vx = Math.cos(entity.glowTime * 0.6) * 0.3;
            
            // ÂõûÂæ©„Ç™„Éº„É©
            if (Math.random() < 0.02) {
                createHealingParticle(entity.x, entity.y);
            }
        }

        function updatePowerUpGlow(entity) {
            // „Éë„ÉØ„Éº„Ç¢„ÉÉ„Éó„Ç¢„Ç§„ÉÜ„É†„ÅÆÂÖâ„ÇãÂãï„Åç
            entity.glowIntensity = Math.sin(entity.glowTime * 3) * 0.5 + 0.5;
            entity.vy = Math.sin(entity.glowTime * 0.7) * 0.8;
            entity.vx = Math.cos(entity.glowTime * 0.5) * 0.4;
        }

        function updateSpeedBoostSpin(entity) {
            // „Çπ„Éî„Éº„Éâ„Éñ„Éº„Çπ„Éà„ÅÆÂõûËª¢
            entity.angle += 0.1;
            entity.vy = Math.sin(entity.glowTime * 0.9) * 0.6;
            entity.vx = Math.cos(entity.glowTime * 0.7) * 0.8;
        }

        function updateDriftingBehavior(entity) {
            entity.vx = Math.sin(entity.glowTime * 0.5) * 0.5;
            entity.vy = Math.cos(entity.glowTime * 0.3) * 0.3 + 0.2;
        }

        function updateWanderingBehavior(entity) {
            if (!entity.targetX || Math.abs(entity.x - entity.targetX) < 30) {
                entity.targetX = Math.random() * elements.canvas.width;
                entity.targetY = Math.random() * elements.canvas.height;
            }
            
            const dx = entity.targetX - entity.x;
            const dy = entity.targetY - entity.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist > 0) {
                entity.vx = (dx / dist) * entity.speed * 0.4;
                entity.vy = (dy / dist) * entity.speed * 0.4;
            }
        }

        function updateParticles(deltaTime) {
            GameState.particles = GameState.particles.filter(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life -= deltaTime;
                particle.alpha = particle.life / particle.maxLife;
                
                if (particle.gravity) {
                    particle.vy += particle.gravity;
                }
                
                return particle.life > 0;
            });
        }

        function updateBubbles(deltaTime) {
            GameState.bubbles.forEach(bubble => {
                bubble.y -= bubble.speed;
                bubble.x += Math.sin(bubble.y * 0.01 + bubble.shimmer) * 0.8;
                bubble.shimmer += 0.02;
                
                if (bubble.y < -20) {
                    bubble.y = elements.canvas.height + 20;
                    bubble.x = Math.random() * elements.canvas.width;
                }
            });
        }

        function updateSwallowingAnimations(deltaTime) {
            GameState.swallowingAnimations = GameState.swallowingAnimations.filter(anim => {
                anim.life -= deltaTime;
                anim.progress = 1 - (anim.life / anim.maxLife);
                return anim.life > 0;
            });
        }

        function updateSkills(deltaTime) {
            // ÊôÇÈñìÂÅúÊ≠¢
            if (GameState.isTimeFreeze) {
                GameState.freezeTime -= deltaTime;
                if (GameState.freezeTime <= 0) {
                    GameState.isTimeFreeze = false;
                }
            }
            
            if (GameState.freezeCooldown > 0) {
                GameState.freezeCooldown -= deltaTime;
            }
            
            // Â∑®Â§ßÂåñ„É¢„Éº„Éâ
            if (GameState.isGiantMode) {
                GameState.giantTime -= deltaTime;
                if (GameState.giantTime <= 0) {
                    GameState.isGiantMode = false;
                    GameState.player.radius = GameState.originalRadius;
                }
            }
            
            if (GameState.giantCooldown > 0) {
                GameState.giantCooldown -= deltaTime;
            }
            
            // Á£ÅÁü≥
            if (GameState.magnetActive) {
                GameState.magnetTime -= deltaTime;
                if (GameState.magnetTime <= 0) {
                    GameState.magnetActive = false;
                }
            }
            
            if (GameState.magnetCooldown > 0) {
                GameState.magnetCooldown -= deltaTime;
            }
            
            // ÊàêÈï∑„Ç®„Éï„Çß„ÇØ„Éà
            if (GameState.growthEffect) {
                GameState.growthTime -= deltaTime;
                if (GameState.growthTime <= 0) {
                    GameState.growthEffect = false;
                }
            }
            
            updateSkillButtons();
        }

        function updateSkillButtons() {
            if (elements.freezeBtn) {
                elements.freezeBtn.disabled = GameState.freezeCooldown > 0 || GameState.energy < 50;
                elements.freezeBtn.textContent = GameState.freezeCooldown > 0 ? 
                    `‚ùÑÔ∏è ${Math.ceil(GameState.freezeCooldown/1000)}s` : '‚ùÑÔ∏è ÊôÇÈñìÂÅúÊ≠¢';
            }
            
            if (elements.growBtn) {
                elements.growBtn.disabled = GameState.giantCooldown > 0 || GameState.energy < 60;
                elements.growBtn.textContent = GameState.giantCooldown > 0 ? 
                    `üêã ${Math.ceil(GameState.giantCooldown/1000)}s` : 'üêã Â∑®Â§ßÂåñ';
            }
            
            if (elements.magnetBtn) {
                elements.magnetBtn.disabled = GameState.magnetCooldown > 0 || GameState.energy < 35;
                elements.magnetBtn.textContent = GameState.magnetCooldown > 0 ? 
                    `üß≤ ${Math.ceil(GameState.magnetCooldown/1000)}s` : 'üß≤ Á£ÅÁü≥';
            }
        }

        function updateBossSystem(deltaTime) {
            // „Éú„ÇπË≠¶ÂëäË°®Á§∫„ÅÆÁÆ°ÁêÜ
            if (GameState.bossWarningTime > 0) {
                GameState.bossWarningTime -= deltaTime;
                if (GameState.bossWarningTime <= 0) {
                    elements.bossWarning.style.display = 'none';
                }
            }
            
            // „Éú„ÇπÂá∫Áèæ„Çø„Ç§„Éû„ÉºÔºà30Áßí„Äú60ÁßíÈñìÈöîÔºâ
            GameState.bossTimer += deltaTime;
            const bossInterval = 30000 + (GameState.level * 5000); // „É¨„Éô„É´„Åå‰∏ä„Åå„Çã„Åª„Å©È†ªÁπÅ„Å´
            
            if (GameState.bossTimer > bossInterval && !GameState.bossActive) {
                spawnBoss();
                GameState.bossTimer = 0;
            }
            
            // „Éú„Çπ„ÅåÂÄí„Åï„Çå„Åü„Åã„ÉÅ„Çß„ÉÉ„ÇØ
            const bossExists = GameState.entities.some(entity => entity.isBoss);
            if (GameState.bossActive && !bossExists) {
                GameState.bossActive = false;
                GameState.score += 500; // „Éú„ÇπÊíÉÁ†¥„Éú„Éº„Éä„Çπ
                createBossDefeatEffect();
            }
        }

        function updateCombo(deltaTime) {
            if (GameState.combo > 0) {
                GameState.comboTimer -= deltaTime;
                if (GameState.comboTimer <= 0) {
                    GameState.combo = 0;
                    elements.comboPanel.style.display = 'none';
                }
            }
        }

        function checkCollisions() {
            const player = GameState.player;
            
            for (let i = GameState.entities.length - 1; i >= 0; i--) {
                const entity = GameState.entities[i];
                const dx = player.x - entity.x;
                const dy = player.y - entity.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < player.radius + entity.radius) {
                    handleCollision(entity, i);
                    break;
                }
            }
        }

        function handleCollision(entity, index) {
            const creatureType = CreatureTypes[entity.type];
            
            if (creatureType.isHealthItem) {
                GameState.player.health = Math.min(100, GameState.player.health + 20);
                GameState.score += creatureType.value;
                createHealingEffect(entity.x, entity.y);
                addCombo();
            } else if (creatureType.isPowerUp) {
                GameState.isInvincible = true;
                GameState.invincibilityTime = 1500;
                GameState.score += creatureType.value;
                createPowerUpEffect(entity.x, entity.y);
                addCombo();
            } else if (creatureType.isSpeedBoost) {
                GameState.player.speed += 0.5;
                GameState.score += creatureType.value;
                createSpeedBoostEffect(entity.x, entity.y);
                addCombo();
            } else if (creatureType.dangerous) {
                if (GameState.isInvincible) {
                    GameState.entities.splice(index, 1);
                    return;
                }
                
                // Â∑®Â§ßÂåñ„É¢„Éº„Éâ‰∏≠„ÅØÈÄöÂ∏∏„Å™„ÇâÂç±Èô∫„Å™È≠ö„ÇÇÈ£ü„Åπ„Çâ„Çå„Çã
                if (GameState.isGiantMode && entity.radius < GameState.player.radius * 0.8) {
                    GameState.score += Math.abs(creatureType.value) * 2; // Âç±Èô∫„Å™È≠ö„ÇíÈ£ü„Åπ„Åü„Éú„Éº„Éä„Çπ
                    createEatEffect(entity.x, entity.y, Math.abs(creatureType.value));
                    addCombo();
                    
                    // „Éú„Çπ„ÅÆÂ†¥Âêà„ÅØ‰ΩìÂäõ„ÇíÊ∏õ„Çâ„Åô
                    if (entity.isBoss) {
                        entity.health = (entity.health || 3) - 1;
                        if (entity.health <= 0) {
                            GameState.entities.splice(index, 1);
                            return;
                        }
                    } else {
                        GameState.entities.splice(index, 1);
                        return;
                    }
                }
                
                let damage = 60;
                if (creatureType.isToxic) damage = 75;
                if (creatureType.isAggressive) damage = 85;
                if (creatureType.isApexPredator) damage = 95;
                if (creatureType.isBoss) damage = 90;
                
                GameState.player.health -= damage;
                GameState.isInvincible = true;
                GameState.invincibilityTime = 400;
                GameState.combo = 0;
                
                createDamageEffect(entity.x, entity.y, damage);
                
                if (GameState.player.health <= 0) {
                    gameOver();
                    return;
                }
            } else {
                // È£ü„Åπ„Çâ„Çå„ÇãÁîüÁâ©
                GameState.score += creatureType.value + (GameState.combo * 3);
                if (creatureType.value > 0) {
                    let growthAmount = 0.4;
                    if (GameState.isGiantMode) growthAmount *= 1.5; // Â∑®Â§ßÂåñ‰∏≠„ÅØÊàêÈï∑„Éú„Éº„Éä„Çπ
                    
                    GameState.player.radius += growthAmount;
                    GameState.oxygen = Math.min(100, GameState.oxygen + 2);
                }
                createEatEffect(entity.x, entity.y, creatureType.value);
                addCombo();
            }
            
            GameState.entities.splice(index, 1);
            updateUI();
        }

        function addCombo() {
            GameState.combo++;
            GameState.comboTimer = 3000;
            elements.comboPanel.style.display = 'block';
            elements.comboValue.textContent = GameState.combo;
            
            // „Ç≥„É≥„Éú„Éú„Éº„Éä„Çπ
            if (GameState.combo >= 10) {
                GameState.energy = Math.min(100, GameState.energy + 20);
            }
        }

        function spawnNewEntities() {
            const spawnRate = 0.012 + (GameState.level * 0.002);
            if (Math.random() < spawnRate) {
                spawnEntity();
            }
        }

        function updateOxygen(deltaTime) {
            GameState.oxygen -= 0.035;
            if (GameState.oxygen <= 0) {
                gameOver();
            }
        }

        function updateEnergy(deltaTime) {
            GameState.energy = Math.min(100, GameState.energy + 0.005);
        }

        function checkLevelUp() {
            const newLevel = Math.floor(GameState.score / 500) + 1;
            if (newLevel > GameState.level) {
                GameState.level = newLevel;
                createLevelUpEffect();
                updateUI();
            }
        }

        function checkGrowthEffect() {
            if (GameState.player.radius > GameState.lastGrowthSize + 8) {
                GameState.growthEffect = true;
                GameState.growthTime = 1500;
                GameState.lastGrowthSize = GameState.player.radius;
                
                createGrowthEffect();
                
                // ÊàêÈï∑ÊôÇ„ÅÆÁâπÊÆäÂäπÊûú
                if (!GameState.slowMotionActive) {
                    GameState.slowMotionActive = true;
                    GameState.slowMotionTime = 800;
                    elements.slowMotionEffect.classList.add('active');
                }
            }
        }

        // „Ç®„Éï„Çß„ÇØ„ÉàÈñ¢Êï∞
        function createDashEffect() {
            for (let i = 0; i < 12; i++) {
                GameState.particles.push({
                    x: GameState.player.x + (Math.random() - 0.5) * 30,
                    y: GameState.player.y + (Math.random() - 0.5) * 30,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    color: '#00FFFF',
                    life: 800,
                    maxLife: 800,
                    alpha: 1,
                    size: 4
                });
            }
        }

        function createEatEffect(x, y, value) {
            const color = value > 0 ? '#00FF00' : '#FF0000';
            for (let i = 0; i < 6; i++) {
                GameState.particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    color: color,
                    life: 600,
                    maxLife: 600,
                    alpha: 1,
                    size: 3
                });
            }
        }

        function createHealingEffect(x, y) {
            for (let i = 0; i < 8; i++) {
                GameState.particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 3,
                    vy: (Math.random() - 0.5) * 3,
                    color: '#00FF00',
                    life: 1000,
                    maxLife: 1000,
                    alpha: 1,
                    size: 5
                });
            }
        }

        function createPowerUpEffect(x, y) {
            for (let i = 0; i < 15; i++) {
                GameState.particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6,
                    color: '#FFD700',
                    life: 1200,
                    maxLife: 1200,
                    alpha: 1,
                    size: 6
                });
            }
        }

        function createSpeedBoostEffect(x, y) {
            for (let i = 0; i < 10; i++) {
                GameState.particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 5,
                    vy: (Math.random() - 0.5) * 5,
                    color: '#FF4500',
                    life: 800,
                    maxLife: 800,
                    alpha: 1,
                    size: 4
                });
            }
        }

        function createDamageEffect(x, y, damage) {
            for (let i = 0; i < Math.min(damage / 5, 15); i++) {
                GameState.particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6,
                    color: '#FF0000',
                    life: 1000,
                    maxLife: 1000,
                    alpha: 1,
                    size: 5
                });
            }
        }

        function createGrowthEffect() {
            for (let i = 0; i < 20; i++) {
                GameState.particles.push({
                    x: GameState.player.x + (Math.random() - 0.5) * 60,
                    y: GameState.player.y + (Math.random() - 0.5) * 60,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    color: '#FFD700',
                    life: 1500,
                    maxLife: 1500,
                    alpha: 1,
                    size: 8
                });
            }
        }

        function createLevelUpEffect() {
            for (let i = 0; i < 30; i++) {
                GameState.particles.push({
                    x: GameState.player.x + (Math.random() - 0.5) * 80,
                    y: GameState.player.y + (Math.random() - 0.5) * 80,
                    vx: (Math.random() - 0.5) * 5,
                    vy: (Math.random() - 0.5) * 5,
                    color: '#FF69B4',
                    life: 2000,
                    maxLife: 2000,
                    alpha: 1,
                    size: 10
                });
            }
        }

        function createToxicParticle(x, y) {
            GameState.particles.push({
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                color: '#9400D3',
                life: 2000,
                maxLife: 2000,
                alpha: 0.7,
                size: 3
            });
        }

        function createHealingParticle(x, y) {
            GameState.particles.push({
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 1,
                vy: (Math.random() - 0.5) * 1,
                color: '#00FF7F',
                life: 1500,
                maxLife: 1500,
                alpha: 0.8,
                size: 4
            });
        }

        function createInflationEffect(x, y) {
            for (let i = 0; i < 8; i++) {
                GameState.particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 3,
                    vy: (Math.random() - 0.5) * 3,
                    color: '#FFFF00',
                    life: 800,
                    maxLife: 800,
                    alpha: 1,
                    size: 6
                });
            }
        }

        function createThreatEffect(x, y) {
            for (let i = 0; i < 5; i++) {
                GameState.particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    color: '#8B0000',
                    life: 1000,
                    maxLife: 1000,
                    alpha: 0.8,
                    size: 7
                });
            }
        }

        function createInkCloud(x, y) {
            for (let i = 0; i < 20; i++) {
                GameState.particles.push({
                    x: x + (Math.random() - 0.5) * 30,
                    y: y + (Math.random() - 0.5) * 30,
                    vx: (Math.random() - 0.5) * 3,
                    vy: (Math.random() - 0.5) * 3,
                    color: '#2F4F4F',
                    life: 4000,
                    maxLife: 4000,
                    alpha: 0.9,
                    size: 8
                });
            }
        }

        function createSwallowingAnimation(entity) {
            GameState.swallowingAnimations.push({
                playerX: GameState.player.x,
                playerY: GameState.player.y,
                preyX: entity.x,
                preyY: entity.y,
                preySize: entity.radius,
                preyColor: entity.color,
                progress: 0,
                life: 800,
                maxLife: 800
            });
        }

        // ÊèèÁîªÈñ¢Êï∞
        function render() {
            const ctx = elements.ctx;
            const canvas = elements.canvas;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawBubbles(ctx);
            drawParticles(ctx);
            drawEntities(ctx);
            drawSwallowingAnimations(ctx);
            drawPlayer(ctx);
            
            if (GameState.growthEffect) {
                drawGrowthEffect(ctx);
            }
        }

        function drawBubbles(ctx) {
            GameState.bubbles.forEach(bubble => {
                ctx.save();
                ctx.globalAlpha = bubble.alpha;
                
                const gradient = ctx.createRadialGradient(
                    bubble.x - bubble.radius * 0.3, 
                    bubble.y - bubble.radius * 0.3, 
                    0, 
                    bubble.x, 
                    bubble.y, 
                    bubble.radius
                );
                gradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0.3)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(bubble.x, bubble.y, bubble.radius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            });
        }

        function drawParticles(ctx) {
            GameState.particles.forEach(particle => {
                ctx.save();
                ctx.globalAlpha = particle.alpha;
                ctx.fillStyle = particle.color;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size || 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
        }

        function drawEntities(ctx) {
            GameState.entities.forEach(entity => {
                drawCreature(ctx, entity);
            });
        }

        function drawCreature(ctx, entity) {
            ctx.save();
            ctx.translate(entity.x, entity.y);
            ctx.rotate(entity.angle);
            
            // „Éú„Çπ„ÅÆÁâπÂà•„Å™ÂäπÊûú
            if (entity.isBoss) {
                const bossGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, entity.radius + 40);
                bossGradient.addColorStop(0, 'rgba(255, 0, 0, 0.3)');
                bossGradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                ctx.fillStyle = bossGradient;
                ctx.beginPath();
                ctx.arc(0, 0, entity.radius + 40, 0, Math.PI * 2);
                ctx.fill();
                
                // „Éú„Çπ„ÅÆ‰ΩìÂäõË°®Á§∫
                ctx.save();
                ctx.rotate(-entity.angle);
                ctx.fillStyle = 'red';
                ctx.fillRect(-entity.radius, -entity.radius - 20, entity.radius * 2, 4);
                ctx.fillStyle = 'green';
                const healthWidth = (entity.health / 3) * entity.radius * 2;
                ctx.fillRect(-entity.radius, -entity.radius - 20, healthWidth, 4);
                ctx.restore();
            }
            
            // Âç±Èô∫Â∫¶„Å´Âøú„Åò„ÅüË≠¶Âëä„Ç®„Éï„Çß„ÇØ„Éà
            if (entity.dangerous && entity.aiState === 'chasing') {
                ctx.save();
                ctx.globalAlpha = 0.3 + Math.sin(Date.now() * 0.01) * 0.2;
                ctx.strokeStyle = '#FF0000';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(0, 0, entity.radius + 15, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }
            
            // ÊîªÊíÉ‰∏≠„ÅÆÂäπÊûú
            if (entity.isAttacking) {
                ctx.save();
                ctx.globalAlpha = 0.6;
                ctx.strokeStyle = '#FF4500';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(0, 0, entity.radius + 8, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }
            
            // ÊôÇÈñìÂÅúÊ≠¢„ÅÆÂΩ±Èüø„ÇíÂèó„Åë„Å¶„ÅÑ„ÇãË°®Á§∫
            if (GameState.isTimeFreeze && !entity.isBoss) {
                ctx.save();
                ctx.globalAlpha = 0.3;
                ctx.fillStyle = 'rgba(135, 206, 250, 0.5)';
                ctx.beginPath();
                ctx.arc(0, 0, entity.radius + 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
            
            // „Éë„ÉØ„Éº„Ç¢„ÉÉ„Éó„Ç¢„Ç§„ÉÜ„É†„ÅÆÂÖâ„ÇãÂäπÊûú
            if (entity.type === 'POWER_UP' || entity.type === 'SPEED_BOOST') {
                ctx.save();
                ctx.globalAlpha = entity.glowIntensity || 0.5;
                const glowGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, entity.radius + 20);
                glowGradient.addColorStop(0, entity.color);
                glowGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = glowGradient;
                ctx.beginPath();
                ctx.arc(0, 0, entity.radius + 20, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
            
            // Á£ÅÁü≥ÂäπÊûú„ÅÆË°®Á§∫
            if (GameState.magnetActive && !entity.dangerous && entity.value > 0) {
                const dx = GameState.player.x - entity.x;
                const dy = GameState.player.y - entity.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 200) {
                    ctx.save();
                    ctx.globalAlpha = 0.5;
                    ctx.strokeStyle = '#00FFFF';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(dx, dy);
                    ctx.stroke();
                    ctx.restore();
                }
            }
            
            // ‰Ωì„ÅÆ„Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥
            const bodyGradient = ctx.createRadialGradient(-entity.radius * 0.3, -entity.radius * 0.2, 0, 0, 0, entity.radius);
            bodyGradient.addColorStop(0, entity.color);
            bodyGradient.addColorStop(1, adjustColor(entity.color, -50));
            
            ctx.fillStyle = bodyGradient;
            ctx.beginPath();
            
            // È≠ö„ÅÆÂΩ¢Áä∂
            if (['SMALL_FISH', 'HORSE_MACKEREL', 'TUNA', 'SALMON', 'BARRACUDA', 'GREAT_WHITE_SHARK', 'BABY_SHARK', 'AGGRESSIVE_FISH', 'SWORDFISH', 'HAMMERHEAD_SHARK'].includes(entity.type)) {
                ctx.ellipse(0, 0, entity.radius, entity.radius * 0.7, 0, 0, Math.PI * 2);
            } else if (entity.type === 'PIRANHA') {
                // „Éî„É©„Éã„Ç¢„ÅØÂ∞ë„ÅóÈã≠„ÅÑÂΩ¢
                ctx.ellipse(0, 0, entity.radius, entity.radius * 0.6, 0, 0, Math.PI * 2);
            } else if (entity.type === 'MORAY_EEL') {
                // „Ç¶„ÉÑ„Éú„ÅØÁ¥∞Èï∑„ÅÑ
                ctx.ellipse(0, 0, entity.radius * 1.5, entity.radius * 0.4, 0, 0, Math.PI * 2);
            } else if (entity.type === 'ELECTRIC_EEL') {
                // ÈõªÊ∞ó„Ç¶„Éä„ÇÆ„ÇÇÁ¥∞Èï∑„ÅÑ
                ctx.ellipse(0, 0, entity.radius * 1.3, entity.radius * 0.5, 0, 0, Math.PI * 2);
            } else {
                ctx.arc(0, 0, entity.radius, 0, Math.PI * 2);
            }
            ctx.fill();
            
            // ÁâπÊÆäÂäπÊûú
            if (entity.type === 'PUFFERFISH' && entity.isInflated) {
                // ËÜ®„Çâ„Çì„Å†„Éï„Ç∞„ÅÆÈáù
                ctx.strokeStyle = '#8B0000';
                ctx.lineWidth = 2;
                for (let i = 0; i < 16; i++) {
                    const angle = (i / 16) * Math.PI * 2;
                    ctx.save();
                    ctx.rotate(angle);
                    ctx.beginPath();
                    ctx.moveTo(entity.radius * 0.8, 0);
                    ctx.lineTo(entity.radius * 1.3, 0);
                    ctx.stroke();
                    ctx.restore();
                }
            }
            
            if (entity.type === 'SWORDFISH') {
                // „Ç´„Ç∏„Ç≠„ÅÆÂâ£
                ctx.fillStyle = '#C0C0C0';
                ctx.beginPath();
                ctx.moveTo(entity.radius, 0);
                ctx.lineTo(entity.radius * 1.8, -entity.radius * 0.1);
                ctx.lineTo(entity.radius * 1.8, entity.radius * 0.1);
                ctx.closePath();
                ctx.fill();
            }
            
            if (entity.type === 'HAMMERHEAD_SHARK') {
                // „Éè„É≥„Éû„Éº„Éò„ÉÉ„Éâ„ÅÆÈ†≠
                ctx.fillStyle = adjustColor(entity.color, -20);
                ctx.beginPath();
                ctx.ellipse(entity.radius * 0.8, 0, entity.radius * 0.6, entity.radius * 0.2, 0, 0, Math.PI * 2);
                ctx.fill();
            }
            
            if (entity.type === 'STINGRAY') {
                // „Ç®„Ç§„ÅÆÂ∞ªÂ∞æ
                ctx.fillStyle = adjustColor(entity.color, -30);
                ctx.beginPath();
                ctx.moveTo(-entity.radius, 0);
                ctx.lineTo(-entity.radius * 1.8, -entity.radius * 0.2);
                ctx.lineTo(-entity.radius * 1.5, entity.radius * 0.2);
                ctx.closePath();
                ctx.fill();
            }
            
            if (entity.type === 'JELLYFISH') {
                // „ÇØ„É©„Ç≤„ÅÆËß¶Êâã
                ctx.strokeStyle = adjustColor(entity.color, -20);
                ctx.lineWidth = 3;
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    ctx.save();
                    ctx.rotate(angle);
                    ctx.beginPath();
                    ctx.moveTo(entity.radius * 0.8, 0);
                    ctx.lineTo(entity.radius * 1.8, Math.sin(entity.glowTime * 2 + i) * 10);
                    ctx.stroke();
                    ctx.restore();
                }
            }
            
            if (entity.type === 'GIANT_OCTOPUS') {
                // Â∑®Â§ß„Çø„Ç≥„ÅÆËß¶Êâã
                ctx.strokeStyle = adjustColor(entity.color, -20);
                ctx.lineWidth = 6;
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    ctx.save();
                    ctx.rotate(angle);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(entity.radius * 1.5, Math.sin(entity.glowTime * 3 + i) * 20);
                    ctx.stroke();
                    ctx.restore();
                }
            }
            
            if (entity.type === 'ELECTRIC_EEL') {
                // ÈõªÊ∞ó„Ç®„Éï„Çß„ÇØ„Éà
                if (Math.random() < 0.3) {
                    ctx.strokeStyle = '#FFFF00';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(-entity.radius, (i - 1) * entity.radius * 0.3);
                        ctx.lineTo(entity.radius, (i - 1) * entity.radius * 0.3);
                        ctx.stroke();
                    }
                }
            }
            
            if (entity.type === 'PIRANHA') {
                // „Éî„É©„Éã„Ç¢„ÅÆÈã≠„ÅÑÊ≠Ø
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.moveTo(entity.radius * 0.6, -entity.radius * 0.1);
                ctx.lineTo(entity.radius * 0.8, -entity.radius * 0.1);
                ctx.lineTo(entity.radius * 0.7, entity.radius * 0.1);
                ctx.closePath();
                ctx.fill();
            }
            
            // ÁõÆÔºà„Ç¢„Ç§„ÉÜ„É†‰ª•Â§ñÔºâ
            if (!['TREASURE', 'HEALTH_POTION', 'POWER_UP', 'SPEED_BOOST'].includes(entity.type)) {
                const eyeSize = entity.radius * 0.12;
                const eyeX = entity.type === 'MORAY_EEL' ? entity.radius * 0.6 : entity.radius * 0.4;
                const eyeY = -entity.radius * 0.2;
                
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(eyeX, eyeY, eyeSize, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = entity.dangerous ? 'red' : 'black';
                ctx.beginPath();
                ctx.arc(eyeX, eyeY, eyeSize * 0.7, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Âç±Èô∫„Å™ÁîüÁâ©„ÅÆÁ∏ÅÂèñ„Çä
            if (entity.dangerous) {
                ctx.strokeStyle = entity.isBoss ? '#FF0000' : '#FF4500';
                ctx.lineWidth = entity.isBoss ? 4 : 2;
                ctx.stroke();
            }
            
            ctx.restore();
        }

        function drawSwallowingAnimations(ctx) {
            GameState.swallowingAnimations.forEach(anim => {
                ctx.save();
                
                const lerpX = anim.preyX + (anim.playerX - anim.preyX) * anim.progress;
                const lerpY = anim.preyY + (anim.playerY - anim.preyY) * anim.progress;
                const scale = 1 - anim.progress * 0.9;
                
                ctx.globalAlpha = 1 - anim.progress * 0.6;
                ctx.translate(lerpX, lerpY);
                ctx.scale(scale, scale);
                
                ctx.fillStyle = anim.preyColor;
                ctx.beginPath();
                ctx.arc(0, 0, anim.preySize, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            });
        }

        function drawPlayer(ctx) {
            const player = GameState.player;
            
            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.rotate(player.angle);
            
            // ÁÑ°ÊïµÊôÇ„ÅÆÁÇπÊªÖ„Å®„Ç™„Éº„É©
            if (GameState.isInvincible) {
                const blink = Math.sin(Date.now() * 0.03) > 0;
                if (!blink) {
                    ctx.globalAlpha = 0.6;
                }
                
                // ÁÑ°Êïµ„Ç™„Éº„É©
                const auraGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, player.radius + 25);
                auraGradient.addColorStop(0, 'rgba(255, 255, 0, 0.4)');
                auraGradient.addColorStop(1, 'rgba(255, 255, 0, 0)');
                ctx.fillStyle = auraGradient;
                ctx.beginPath();
                ctx.arc(0, 0, player.radius + 25, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // ÊôÇÈñìÂÅúÊ≠¢ÂäπÊûú
            if (GameState.isTimeFreeze) {
                const freezeGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, player.radius + 20);
                freezeGradient.addColorStop(0, 'rgba(135, 206, 250, 0.6)');
                freezeGradient.addColorStop(1, 'rgba(135, 206, 250, 0)');
                ctx.fillStyle = freezeGradient;
                ctx.beginPath();
                ctx.arc(0, 0, player.radius + 20, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Â∑®Â§ßÂåñÂäπÊûú
            if (GameState.isGiantMode) {
                const giantGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, player.radius + 30);
                giantGradient.addColorStop(0, 'rgba(255, 215, 0, 0.8)');
                giantGradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                ctx.fillStyle = giantGradient;
                ctx.beginPath();
                ctx.arc(0, 0, player.radius + 30, 0, Math.PI * 2);
                ctx.fill();
                
                // Â∑®Â§ßÂåñ„ÅÆËÑàÂãïÂäπÊûú
                const pulse = Math.sin(Date.now() * 0.01) * 0.1 + 0.9;
                ctx.scale(pulse, pulse);
            }
            
            // Á£ÅÁü≥ÂäπÊûú
            if (GameState.magnetActive) {
                const magnetGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, player.radius + 15);
                magnetGradient.addColorStop(0, 'rgba(255, 100, 71, 0.5)');
                magnetGradient.addColorStop(1, 'rgba(255, 100, 71, 0)');
                ctx.fillStyle = magnetGradient;
                ctx.beginPath();
                ctx.arc(0, 0, player.radius + 15, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // ÊàêÈï∑ÂäπÊûú
            if (GameState.growthEffect) {
                const growthGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, player.radius + 35);
                growthGradient.addColorStop(0, 'rgba(255, 215, 0, 0.6)');
                growthGradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                ctx.fillStyle = growthGradient;
                ctx.beginPath();
                ctx.arc(0, 0, player.radius + 35, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // ‰Ωì„ÅÆ„Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥
            const bodyGradient = ctx.createRadialGradient(-player.radius * 0.3, -player.radius * 0.2, 0, 0, 0, player.radius);
            bodyGradient.addColorStop(0, '#FFD700');
            bodyGradient.addColorStop(0.7, player.color);
            bodyGradient.addColorStop(1, adjustColor(player.color, -50));
            
            ctx.fillStyle = bodyGradient;
            ctx.beginPath();
            ctx.ellipse(0, 0, player.radius, player.radius * 0.7, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Â∞ªÂ∞æÔºà„Çà„ÇäË©≥Á¥∞„Å´Ôºâ
            ctx.fillStyle = adjustColor(player.color, -30);
            ctx.beginPath();
            ctx.moveTo(-player.radius, 0);
            ctx.lineTo(-player.radius * 1.6, -player.radius * 0.5);
            ctx.lineTo(-player.radius * 1.3, 0);
            ctx.lineTo(-player.radius * 1.6, player.radius * 0.5);
            ctx.closePath();
            ctx.fill();
            
            // ËÉå„Å≥„Çå
            ctx.beginPath();
            ctx.moveTo(-player.radius * 0.3, -player.radius * 0.7);
            ctx.lineTo(-player.radius * 0.1, -player.radius * 1.2);
            ctx.lineTo(player.radius * 0.3, -player.radius * 0.7);
            ctx.fill();
            
            // ËÉ∏„Å≥„Çå
            ctx.fillStyle = adjustColor(player.color, -20);
            ctx.beginPath();
            ctx.ellipse(player.radius * 0.2, player.radius * 0.3, player.radius * 0.4, player.radius * 0.2, Math.PI * 0.3, 0, Math.PI * 2);
            ctx.fill();
            
            // ÁõÆÔºà„Çà„ÇäË©≥Á¥∞„Å´Ôºâ
            const eyeSize = player.radius * 0.15;
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(player.radius * 0.4, -player.radius * 0.2, eyeSize, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(player.radius * 0.4, -player.radius * 0.2, eyeSize * 0.7, 0, Math.PI * 2);
            ctx.fill();
            
            // Áû≥„ÅÆ„Éè„Ç§„É©„Ç§„Éà
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(player.radius * 0.42, -player.radius * 0.23, eyeSize * 0.3, 0, Math.PI * 2);
            ctx.fill();
            
            // „É¨„Éô„É´Ë°®Á§∫
            ctx.rotate(-player.angle);
            ctx.fillStyle = 'white';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 3;
            ctx.strokeText(GameState.level, 0, 5);
            ctx.fillText(GameState.level, 0, 5);
            
            ctx.restore();
        }

        function drawGrowthEffect(ctx) {
            const player = GameState.player;
            const intensity = GameState.growthTime / 1500;
            
            ctx.save();
            ctx.globalAlpha = intensity * 0.3;
            
            const rings = 3;
            for (let i = 0; i < rings; i++) {
                const radius = player.radius + (i * 20) + (intensity * 50);
                const ringGradient = ctx.createRadialGradient(
                    player.x, player.y, radius * 0.8,
                    player.x, player.y, radius
                );
                ringGradient.addColorStop(0, 'rgba(255, 215, 0, 0.5)');
                ringGradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                
                ctx.fillStyle = ringGradient;
                ctx.beginPath();
                ctx.arc(player.x, player.y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        }

        function updateUI() {
            if (elements.scoreValue) elements.scoreValue.textContent = GameState.score;
            if (elements.levelValue) elements.levelValue.textContent = GameState.level;
            if (elements.healthFill) elements.healthFill.style.width = Math.max(0, GameState.player.health) + '%';
            if (elements.oxygenFill) elements.oxygenFill.style.width = Math.max(0, GameState.oxygen) + '%';
            if (elements.energyFill) elements.energyFill.style.width = Math.max(0, GameState.energy) + '%';
            
            // „Éó„É¨„Ç§„É§„ÉºÊÉÖÂ†±„ÅÆÊõ¥Êñ∞
            if (elements.playerInfo) {
                let fishType = 'üê† Â∞è„Åï„Å™È≠ö';
                if (GameState.player.radius > 50) fishType = 'üêã Êµ∑„ÅÆÁéãËÄÖ';
                else if (GameState.player.radius > 35) fishType = 'ü¶à Â§ßÂûãÈ≠ö';
                else if (GameState.player.radius > 25) fishType = 'üêü ‰∏≠ÂûãÈ≠ö';
                else if (GameState.player.radius > 18) fishType = 'üê† ÊàêÈï∑„Åó„ÅüÈ≠ö';
                
                elements.playerInfo.textContent = fishType;
            }
            
            // ‰ΩìÂäõ„Éê„Éº„ÅÆËâ≤Â§âÊõ¥
            if (elements.healthFill) {
                if (GameState.player.health > 70) {
                    elements.healthFill.style.background = 'linear-gradient(90deg, #00ff00, #90EE90)';
                } else if (GameState.player.health > 40) {
                    elements.healthFill.style.background = 'linear-gradient(90deg, #ffff00, #FFA500)';
                } else {
                    elements.healthFill.style.background = 'linear-gradient(90deg, #ff0000, #FF6347)';
                }
            }
            
            // ÈÖ∏Á¥†„Éê„Éº„ÅÆËâ≤Â§âÊõ¥
            if (elements.oxygenFill) {
                if (GameState.oxygen > 50) {
                    elements.oxygenFill.style.background = 'linear-gradient(90deg, #00ff00, #40E0D0)';
                } else if (GameState.oxygen > 25) {
                    elements.oxygenFill.style.background = 'linear-gradient(90deg, #ffff00, #FFA500)';
                } else {
                    elements.oxygenFill.style.background = 'linear-gradient(90deg, #ff0000, #FF4500)';
                }
            }
            
            // „Çπ„ÉÜ„Éº„Çø„ÇπÂäπÊûú„ÅÆË°®Á§∫
            if (elements.statusEffects) {
                let statusText = '';
                if (GameState.isInvincible) statusText += '‚≠ê ÁÑ°Êïµ ';
                if (GameState.isTimeFreeze) statusText += '‚ùÑÔ∏è ÊôÇÈñìÂÅúÊ≠¢ ';
                if (GameState.isGiantMode) statusText += 'üêã Â∑®Â§ßÂåñ ';
                if (GameState.magnetActive) statusText += 'üß≤ Á£ÅÁü≥ ';
                if (GameState.combo > 0) statusText += `üî• ${GameState.combo}„Ç≥„É≥„Éú `;
                if (GameState.bossActive) statusText += 'üíÄ „Éú„ÇπÂá∫Áèæ‰∏≠ ';
                
                elements.statusEffects.textContent = statusText;
            }
        }

        function gameOver() {
            GameState.gameRunning = false;
            
            if (elements.joystick) elements.joystick.style.display = 'none';
            if (elements.slowMotionEffect) elements.slowMotionEffect.classList.remove('active');
            if (elements.bossWarning) elements.bossWarning.style.display = 'none';
            
            // ÂÆüÁ∏æ„ÅÆË®àÁÆóÔºàÊñ∞Ê©üËÉΩÂØæÂøúÔºâ
            const achievements = [];
            if (GameState.score > 3000) achievements.push('üèÜ Êµ∑Ê¥ã„ÅÆË¶áÁéã');
            else if (GameState.score > 2000) achievements.push('ü•á ‰ºùË™¨„ÅÆÂÜíÈô∫ËÄÖ');
            else if (GameState.score > 1500) achievements.push('ü•à „Éû„Çπ„Çø„ÉºÂÜíÈô∫ËÄÖ');
            else if (GameState.score > 1000) achievements.push('ü•â Â§ßÂÜíÈô∫ËÄÖ');
            else if (GameState.score > 500) achievements.push('üéñÔ∏è ÂÜíÈô∫ËÄÖ');
            
            if (GameState.level >= 10) achievements.push('üåä Ê∑±Êµ∑„ÅÆÂ∏ùÁéã');
            else if (GameState.level >= 8) achievements.push('üåä Ê∑±Êµ∑„ÅÆÊîØÈÖçËÄÖ');
            else if (GameState.level >= 6) achievements.push('üåä Ê∑±Êµ∑Êé¢Ê§úÂÆ∂');
            else if (GameState.level >= 4) achievements.push('üåä Êµ∑Ê¥ãÊé¢Ê§úÂÆ∂');
            
            if (GameState.player.radius > 80) achievements.push('üêã Áµ∂ÂØæÁéãËÄÖ');
            else if (GameState.player.radius > 60) achievements.push('üêã Êµ∑„ÅÆÁµ∂ÂØæÁéãËÄÖ');
            else if (GameState.player.radius > 45) achievements.push('ü¶à Êµ∑„ÅÆÁéãËÄÖ');
            else if (GameState.player.radius > 30) achievements.push('üêü Êµ∑„ÅÆÊîØÈÖçËÄÖ');
            
            if (GameState.combo > 100) achievements.push('üî• „Ç≥„É≥„Éú„É¨„Ç∏„Çß„É≥„Éâ');
            else if (GameState.combo > 50) achievements.push('üî• „Ç≥„É≥„Éú„Éû„Çπ„Çø„Éº');
            else if (GameState.combo > 25) achievements.push('üî• „Ç≥„É≥„Éú„Ç≠„É≥„Ç∞');
            
            // Êñ∞Ê©üËÉΩÈñ¢ÈÄ£„ÅÆÂÆüÁ∏æ
            const bossesDefeated = Math.floor(GameState.score / 1000); // Ê¶ÇÁÆó
            if (bossesDefeated >= 5) achievements.push('üíÄ „Éú„Çπ„Éè„É≥„Çø„Éº');
            else if (bossesDefeated >= 3) achievements.push('üíÄ „Éú„Çπ„Ç≠„É©„Éº');
            else if (bossesDefeated >= 1) achievements.push('üíÄ „Éú„Çπ„Çπ„É¨„Ç§„É§„Éº');
            
            if (GameState.player.radius > 50) achievements.push('‚ùÑÔ∏è ÊôÇÁ©∫Êìç‰ΩúËÄÖ');
            if (GameState.player.radius > 40) achievements.push('üêã Â§âË∫´„Éû„Çπ„Çø„Éº');
            if (GameState.combo > 30) achievements.push('üß≤ ÂºïÂäõ‰Ωø„ÅÑ');
            
            // ÁâπÂà•ÂÆüÁ∏æ
            if (GameState.score > 2500 && GameState.combo > 50) {
                achievements.push('üëë ÂÆåÁíß„Å™ÂÜíÈô∫ËÄÖ');
            }
            
            if (elements.finalScore) elements.finalScore.textContent = `ÊúÄÁµÇ„Çπ„Ç≥„Ç¢: ${GameState.score}`;
            if (elements.achievements) {
                elements.achievements.innerHTML = achievements.length > 0 ? 
                    achievements.join('<br>') : 'ÂÜçÊåëÊà¶„Åó„Å¶ÂÆüÁ∏æ„ÇíÁç≤Âæó„Åó„Çà„ÅÜÔºÅ';
            }
            if (elements.gameOverScreen) elements.gameOverScreen.style.display = 'flex';
            
            if (GameState.animationId) {
                cancelAnimationFrame(GameState.animationId);
            }
        }

        // Ëâ≤Ë™øÊï¥Èñ¢Êï∞
        function adjustColor(color, amount) {
            // hexËâ≤„ÅÆÂ†¥Âêà
            if (color.startsWith('#')) {
                const hex = color.replace('#', '');
                const r = Math.max(0, Math.min(255, parseInt(hex.substr(0, 2), 16) + amount));
                const g = Math.max(0, Math.min(255, parseInt(hex.substr(2, 2), 16) + amount));
                const b = Math.max(0, Math.min(255, parseInt(hex.substr(4, 2), 16) + amount));
                return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
            }
            
            // rgbËâ≤„ÅÆÂ†¥Âêà
            if (color.startsWith('rgb')) {
                const matches = color.match(/\d+/g);
                if (matches && matches.length >= 3) {
                    const r = Math.max(0, Math.min(255, parseInt(matches[0]) + amount));
                    const g = Math.max(0, Math.min(255, parseInt(matches[1]) + amount));
                    const b = Math.max(0, Math.min(255, parseInt(matches[2]) + amount));
                    return `rgb(${r}, ${g}, ${b})`;
                }
            }
            
            return color;
        }

        // ÂàùÊúüÂåñÂÆüË°å
        let initialized = false;
        
        function safeInit() {
            if (initialized) return;
            console.log('Ë∂ÖÈÄ≤ÂåñÁâàÂàùÊúüÂåñÂÆüË°å');
            init();
            initialized = true;
        }
        
        // Ë§áÊï∞„ÅÆ„Çø„Ç§„Éü„É≥„Ç∞„ÅßÂàùÊúüÂåñ„ÇíË©¶Ë°å
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', safeInit);
        } else {
            safeInit();
        }
        
        window.addEventListener('load', safeInit);
        
        // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÂàùÊúüÂåñ
        setTimeout(safeInit, 100);
        setTimeout(safeInit, 500);
        setTimeout(safeInit, 1000);
        setTimeout(function() {
            if (!initialized) {
                console.log('Âº∑Âà∂ÂàùÊúüÂåñÂÆüË°å');
                init();
                initialized = true;
            }
        }, 2000);
        
        // „Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞
        window.addEventListener('error', function(e) {
            console.error('„Ç≤„Éº„É†„Ç®„É©„Éº:', e.error);
        });
        
        // „Çø„ÉÉ„ÉÅ„Ç§„Éô„É≥„Éà„ÅÆÊúÄÈÅ©Âåñ
        document.addEventListener('touchmove', function(e) {
            e.preventDefault();
        }, { passive: false });
        
        // „Éö„Éº„Ç∏Èõ¢ËÑ±ÊôÇ„ÅÆ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
        window.addEventListener('beforeunload', function() {
            if (GameState.animationId) {
                cancelAnimationFrame(GameState.animationId);
            }
        });
        
        console.log('=== Ë∂ÖÈÄ≤ÂåñÁâàÊµ∑„ÅÆÂ§ßÂÜíÈô∫„Ç≤„Éº„É†Ë™≠„ÅøËæº„ÅøÂÆå‰∫Ü ===');
    </script>
</body>
</html>
